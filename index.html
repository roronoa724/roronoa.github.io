<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="you cannot win with a losing hand">
<meta property="og:type" content="website">
<meta property="og:title" content="roronoa space">
<meta property="og:url" content="http://roronoa.space/index.html">
<meta property="og:site_name" content="roronoa space">
<meta property="og:description" content="you cannot win with a losing hand">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="roronoa space">
<meta name="twitter:description" content="you cannot win with a losing hand">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://roronoa.space/"/>





  <title> roronoa space </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">roronoa space</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">three thousand worlds</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://roronoa.space/2017/07/04/Java_concurrency_basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="roronoa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="roronoa space">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/04/Java_concurrency_basic/" itemprop="url">
                  Java并发编程必备基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-04T21:21:00+08:00">
                2017-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">本文转载自http://ifeve.com/高并发编程必备基础/ by 加多</div></pre></td></tr></table></figure>
<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>借用Java并发编程实践中的话”编写正确的程序并不容易，而编写正常的并发程序就更难了”，相比于顺序执行的情况，多线程的线程安全问题是微妙而且出乎意料的，因为在没有进行适当同步的情况下多线程中各个操作的顺序是不可预期的，本文算是对多线程情况下同步策略的一个简单介绍。</p>
<h2 id="二-什么是线程安全问题"><a href="#二-什么是线程安全问题" class="headerlink" title="二. 什么是线程安全问题"></a>二. 什么是线程安全问题</h2><p><font color="#800000">线程安全问题</font>是指当多个线程同时读写一个状态变量，并且没有任何同步措施时候，导致脏数据或者其他不可预见的结果的问题。Java中首要的同步策略是使用<font color="#800000">synchronized</font>关键字，它提供了可重入的独占锁。</p>
<h2 id="三-什么是共享变量可见性问题"><a href="#三-什么是共享变量可见性问题" class="headerlink" title="三. 什么是共享变量可见性问题"></a>三. 什么是共享变量可见性问题</h2><p>要谈可见性首先需要介绍下多线程处理共享变量时候的Java中内存模型。<br>在Java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。局部变量(Local Variables)、方法定义参数(Formal Method Parameters)和异常处理器参数(Exception Handler Parameters)不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。<br>Java线程之间的通信由Java内存模型(简称<strong>JMM</strong>)控制，JMM决定一个线程对共享变量的写入何时可对另一个线程可见。从抽象的角度看，JMM定义了线程和主内存之间的抽象关系：<strong>线程之间的共享变量存储在<font color="#800000">主内存(Main Memory)</font>之中，每个线程都有一个私有的<font color="#800000">本地内存(Local Memory)</font>，本地内存中存储了该线程以读/写共享变量的副本。</strong>本地内存是JMM的一个抽象概念，其并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。Java的内存模型抽象示意如下图所示。<br><img src="http://osio2xhqh.bkt.clouddn.com/image/png/jmm-1.png?imageMogr2/thumbnail/!50p" alt="jmm-1"><br>Java内存模型规定了所有的变量都存放在主内存中，当线程使用变量时候都是把主内存里面的变量拷贝到了自己的本地内存当中。<br><img src="http://osio2xhqh.bkt.clouddn.com/image/png/jmm-2.png?imageMogr2/thumbnail/!50p" alt="jmm-2"><br>上图是双核CPU系统架构，每核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辑运算，并且有自己的一级缓存，并且有些架构里面双核还有个共享的二级缓存。对应Java内存模型里面的工作内存，在实现上这里是指L1或者L2缓存或者自己cpu的寄存器。<br>当线程操作一个共享变量时候操作流程为：  </p>
<ul>
<li>线程首先从主内存拷贝共享变量到自己的工作空间。</li>
<li>然后对工作空间里的变量进行处理。</li>
<li>处理完后更新变量值到主内存。  </li>
</ul>
<p>那么假如线程A和B同时去处理一个共享变量，会出现什么情况？<br>首先他们都会去走上面的三个流程，假如线程A拷贝共享变量到了工作内存，并且已经对数据进行了更新但是还没有更新会主内存（结果可能目前存放在当前cpu的寄存器或者高速缓存），这时候线程B拷贝共享变量到了自己的工作内存进行处理，处理后，线程A才把自己的处理结果更更新到主内存或者缓存，可知 线程B处理的并不是线程A处理后的结果，也就是说线程A处理后的变量值对线程B不可见，这就是共享变量的<strong>不可见性问题</strong>。<br>构成共享变量内存不可见原因是因为三步流程不是原子性操作，我们知道ArrayList是线程不安全的，因为他的读写方法没有同步策略，会导致脏数据和不可预期的结果。下面会讲到使用恰当同步就可以解决这个问题。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 这是线程不安全的</div><div class="line">public class ArrayList&lt;E&gt; </div><div class="line">&#123;</div><div class="line">    public E get(int index) &#123;</div><div class="line">        rangeCheck(index);</div><div class="line">        </div><div class="line">        return elementData(index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public E set(int index, E element) &#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        E oldValue = elementData(index);</div><div class="line">        elementData[index] = element;</div><div class="line">        return oldValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="四-原子性"><a href="#四-原子性" class="headerlink" title="四. 原子性"></a>四. 原子性</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p>假设线程A执行操作Ao和线程B执行操作Bo，那么从A看，当B线程执行Bo操作时候，那么Bo操作全部执行，要么全部不执行，我们称Ao和Bo操作互为原子性操作，在设计计数器时候一般都是先读取当前值，然后+1，然后更新会变量，是读-改-写的过程，这个过程必须是原子性的操作。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">public class ThreadUnsafeTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">        List&lt;Thread&gt; incThreads = new ArrayList&lt;&gt;();</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            incThreads.add(new Thread(new IncRunnable()));</div><div class="line">        &#125;</div><div class="line">        incThreads.stream().forEach(thread -&gt; &#123;</div><div class="line">            thread.start();</div><div class="line">        &#125;);</div><div class="line">        // 等待所有子线程执行完毕</div><div class="line">        Thread.sleep(500);</div><div class="line">        System.out.println(IncRunnable.getCount());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class IncRunnable implements Runnable &#123;</div><div class="line"></div><div class="line">    static ThreadUnsafeCounter threadUnsafeCounter = new ThreadUnsafeCounter();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        for (int i = 0; i &lt; 10000; i++) &#123;</div><div class="line">            threadUnsafeCounter.inc();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static int getCount() &#123;</div><div class="line">        return threadUnsafeCounter.getCount();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ThreadUnsafeCounter &#123;</div><div class="line">    private int count = 0;</div><div class="line"></div><div class="line">    public int getCount() &#123;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void inc() &#123;</div><div class="line">        ++count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码启动五个子线程，每个子线程对计数器对象循环进行自增操作10000次。预期结果应该为50000。但是因为ThreadUnsafeCounter计数器对count的自增操作是非线程安全的(读-改-写)，对照上文讲解的Java内存模型，五个线程可能同时从内存中读取相同count值到自己的本地内存，修改后再写回内存，对我们而言，带来的结果只是count自增了一次而已。所以产生的结果极大可能性不符合我们的预期。在笔者的笔记本上运行该段代码后得到的结果为13560，与预期的结果相差甚远。<br>为了实现线程安全的操作，方法一是使用<font color="#800000">Synchronized</font>对计数器的方法进行同步如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class ThreadSafeCounter &#123;</div><div class="line">    private int count = 0;</div><div class="line"></div><div class="line">    public synchronized int getCount() &#123;</div><div class="line">        return count;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized void inc() &#123;</div><div class="line">        count += 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用Synchronized改写后，我们可以看到输出为预期结果50000。注意，这里不能简单的使用volatile修饰value进行同步，因为变量值依赖了当前值。<br>使用Synchronized确实可以实现线程安全，即实现可见性和同步，但是Synchronized是独占锁，没有获取内部锁的线程会被阻塞掉，那么有没有刚好的实现？答案是肯定的。</p>
<h3 id="4-2-原子变量类"><a href="#4-2-原子变量类" class="headerlink" title="4.2 原子变量类"></a>4.2 原子变量类</h3><p>原子变量类比锁更轻巧，比如AtomicInteger代表了一个Integer值，并提供了get,set方法，get，set方法语义和volatile相同，因为AtomicInteger内部就是使用了volatile修饰的真正的Integer变量。另外提供了原子性的自增自减操作，所以计数器可以改下为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class ThreadSafeCounter &#123;</div><div class="line">    private AtomicInteger count = new AtomicInteger(0);</div><div class="line"></div><div class="line">    public synchronized int getCount() &#123;</div><div class="line">        return count.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized void inc() &#123;</div><div class="line">        count.getAndIncrement();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相比使用Synchronized的好处在于原子类操作不会导致线程的挂起和重新调度，因为他内部使用的是<font color="#800000">CAS</font>的非阻塞算法。<br>常用的原子类变量为：AtomicLong、AtomicInteger、AtomicBoolean和AtomicReference。</p>
<h2 id="五-CAS介绍"><a href="#五-CAS介绍" class="headerlink" title="五. CAS介绍"></a>五. CAS介绍</h2><p><font color="#800000">CAS</font>是CompareAndSet的缩写，也就是比较并设置，CAS有三个操作数分别为：<strong>内存位置</strong>，<strong>旧的预期值</strong>，<strong>新的值</strong>。操作含义是当内存位置的变量值为旧的预期值时候使用新的值替换旧的值。通俗的说就是看内存位置的变量值是不是我给的旧的预期值，如果是则使用我给的新的值替换他，如果不是返回给我旧值。这个是处理器提供的一个原子性指令。AtomicLong的自增就是使用这种方式实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public final long incrementAndGet() &#123;</div><div class="line">    for (;;) &#123;</div><div class="line">        long current = get();（1）</div><div class="line">        long next = current + 1;（2）</div><div class="line">        if (compareAndSet(current, next))（3）</div><div class="line">            return next;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public final boolean compareAndSet(long expect, long update) &#123;</div><div class="line">    return unsafe.compareAndSwapLong(this, valueOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假如当前值为1，那么线程A和检查B同时执行到了（3）时候各自的next都是2，current=1，假如线程A先执行了3，那么这个是原子性操作，会把当前值更新为2并且返回1，if判断true所以incrementAndGet返回2。这时候线程B执行3，因为current=1而当前变量实际值为2，所以if判断为false，继续循环，如果没有其他线程去自增变量的话，这次线程B就会更新变量为3然后退出。<br>这里使用了无限循环使用CAS进行轮询检查，虽然一定程度浪费了cpu资源，但是相比锁来说避免的线程上下文切换和调度。</p>
<h2 id="六-什么是可重入锁"><a href="#六-什么是可重入锁" class="headerlink" title="六.什么是可重入锁"></a>六.什么是可重入锁</h2><p>当一个线程要获取一个被其他线程占用的锁时候，该线程会被阻塞，那么当一个线程再次获取它自己已经获取的锁时候是否会被阻塞呢？如果不需要阻塞那么我们说该锁是<strong>可重入锁</strong>，也就是说只要该线程获取了该锁，那么可以无限制次数进入被该锁锁住的代码。<br>先看一个例子如果锁不是可重入的，看看会出现什么问题。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Hello &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new Hello().printB();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized void printA() &#123;</div><div class="line">        System.out.println(&quot;printA&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized void printB() &#123;</div><div class="line">        System.out.println(&quot;printB&quot;);</div><div class="line">        printA();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上面代码当调用printB函数前会先获取内置锁，然后打印输出，然后调用helloA方法，调用前会先去获取内置锁，如果内置锁不是可重入的那么该调用就会导致死锁了，因为线程持有并等待了锁。<br>实际上<strong>内部锁是可重入锁</strong>，例如synchronized关键字管理的方法，可重入锁的原理是在锁内部维护了一个线程标示，标示该锁目前被那个线程占用，然后关联一个计数器，一开始计数器值为0，说明该锁没有被任何线程占用，当一个线程获取了该锁，计数器会变成1，其他线程在获取该锁时候发现锁的所有者不是自己所以被阻塞，但是当获取该锁的线程再次获取锁时候发现锁拥有者是自己会把计数器值+1，当释放锁后计数器会-1，当计数器为0时候，锁里面的线程标示重置为null，这时候阻塞的线程会获取被唤醒来获取该锁。</p>
<h2 id="七-Synchronized关键字"><a href="#七-Synchronized关键字" class="headerlink" title="七.Synchronized关键字"></a>七.Synchronized关键字</h2><h3 id="7-1-Synchronized介绍"><a href="#7-1-Synchronized介绍" class="headerlink" title="7.1 Synchronized介绍"></a>7.1 Synchronized介绍</h3><p><font color="#800000">synchronized</font>块是Java提供的一种强制性内置锁，每个Java对象都可以隐式的充当一个用于同步的锁的功能，这些内置的锁被称为<strong>内部锁</strong>或者叫<strong>监视器锁</strong>，执行代码在进入synchronized代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时候会阻塞掉。拿到内部锁的线程会在正常退出同步代码块或者异常抛出后释放内部锁，这时候阻塞掉的线程才能获取内部锁进入同步代码块。  </p>
<h3 id="7-2-Synchronized同步实例"><a href="#7-2-Synchronized同步实例" class="headerlink" title="7.2 Synchronized同步实例"></a>7.2 Synchronized同步实例</h3><p>内部锁是一种<strong>互斥锁</strong>，具体说是同时只有一个线程可以拿到该锁，当一个线程拿到该锁并且没有释放的情况下，其他线程只能等待。<br>对于上面说的ArrayList可以使用synchronized进行同步来处理可见性问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 使用synchronized对方法进行同步</div><div class="line">public class ArrayList&lt;E&gt;</div><div class="line">&#123;</div><div class="line">    public synchronized E get(int index) &#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        return elementData(index);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized E set(int index, E element) &#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        E oldValue = elementData(index);</div><div class="line">        elementData[index] = element;</div><div class="line">        return oldValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://osio2xhqh.bkt.clouddn.com/image/png/sync-1.png?imageMogr2/thumbnail/!50p" alt="sync-1"><br>如上图当线程A获取内部锁进入同步代码块后，线程B也准备要进入同步块，但是由于A还没释放锁，所以B现在进入等待，使用同步可以保证线程A获取锁到释放锁期间的变量值对B获取锁后都可见。也就是说当B开始执行A执行的代码同步块时候可以看到A操作的所有变量值，这里具体说是当线程B获取b的值时候能够保证获取的值是2。这时因为<strong>线程A进入同步块修改变量值后，会在退出同步块前把值刷新到主内存，而线程B在进入同步块前会首先清空本地内存内容，从主内存重新获取变量值，所以实现了可见性</strong>。但是要注意一点所有线程使用的是同一个锁。<br>注意，synchronized关键字会引起<strong>线程上下文切换</strong>和<strong>线程调度</strong>。</p>
<h2 id="八-ReentrantReadWriteLock介绍"><a href="#八-ReentrantReadWriteLock介绍" class="headerlink" title="八.ReentrantReadWriteLock介绍"></a>八.ReentrantReadWriteLock介绍</h2><p>使用synchronized可以实现同步，但是缺点是同时只有一个线程可以访问共享变量，但是正常情况下，对于多个读操作操作共享变量时候是不需要同步的，synchronized时候无法实现多个读线程同时执行，而大部分情况下读操作次数多于写操作，所以这大大降低了并发性，所以出现了ReentrantReadWriteLock，它可以实现<strong>读写分离，多个线程同时进行读取，但是最多一个写线程存在</strong>。<br>来看下面这段代码，是对上面ArrayList的一个改写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">import java.util.Random;</div><div class="line">import java.util.concurrent.Callable;</div><div class="line">import java.util.concurrent.ExecutionException;</div><div class="line">import java.util.concurrent.ExecutorService;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line">import java.util.concurrent.locks.Lock;</div><div class="line">import java.util.concurrent.locks.ReadWriteLock;</div><div class="line">import java.util.concurrent.locks.ReentrantReadWriteLock;</div><div class="line"></div><div class="line">public class MyArrayList&lt;E&gt; &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</div><div class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line">        int size = 10;</div><div class="line">        Random random = new Random();</div><div class="line">        MyArrayList&lt;Integer&gt; myArrayList = new MyArrayList&lt;&gt;(size);</div><div class="line">        Runnable writeTask = () -&gt; myArrayList.set(random.nextInt(size), random.nextInt(size));</div><div class="line">        Callable&lt;Integer&gt; readTask = () -&gt; &#123;</div><div class="line">            int element = myArrayList.get(random.nextInt(size));</div><div class="line">            return element;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            executorService.submit(writeTask);</div><div class="line">//            executorService.submit(readTask);</div><div class="line">        &#125;</div><div class="line">        executorService.shutdown();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</div><div class="line">    transient Object[] elementData;</div><div class="line"></div><div class="line">    public MyArrayList(int size) &#123;</div><div class="line">        elementData = new Object[size];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public E get(int index) &#123;</div><div class="line">        Lock readLock = readWriteLock.readLock();</div><div class="line">        readLock.lock();</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;--getReadLock&quot;);</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(1000);</div><div class="line">            return (E) elementData[index];</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            return null;</div><div class="line">        &#125; finally &#123;</div><div class="line">            readLock.unlock();</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;--releaseReadLock&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void set(int index, E element) &#123;</div><div class="line">        Lock writeLock = readWriteLock.writeLock();</div><div class="line">        writeLock.lock();</div><div class="line">        System.out.println(Thread.currentThread().getName() + &quot;--getWriteLock&quot;);</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(1000);</div><div class="line">            elementData[index] = element;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            writeLock.unlock();</div><div class="line">            System.out.println(Thread.currentThread().getName() + &quot;--releaseWriteLock&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码旨在体现ReentrantReadWriteLock的读写分离锁功能。MyArrayList的get和set方法分别使用了读锁和写锁进行锁操作。为了方便测试线程进入互斥区的顺序，get和set操作都设置了1s的延时。main方法中启动10个线程同时对list进行写操作，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">pool-1-thread-2--getWriteLock</div><div class="line">pool-1-thread-2--releaseWriteLock</div><div class="line">pool-1-thread-1--getWriteLock</div><div class="line">pool-1-thread-1--releaseWriteLock</div><div class="line">pool-1-thread-3--getWriteLock</div><div class="line">pool-1-thread-3--releaseWriteLock</div><div class="line">pool-1-thread-4--getWriteLock</div><div class="line">pool-1-thread-4--releaseWriteLock</div><div class="line">pool-1-thread-5--getWriteLock</div><div class="line">pool-1-thread-5--releaseWriteLock</div><div class="line">pool-1-thread-6--getWriteLock</div><div class="line">pool-1-thread-6--releaseWriteLock</div><div class="line">pool-1-thread-7--getWriteLock</div><div class="line">pool-1-thread-7--releaseWriteLock</div><div class="line">pool-1-thread-8--getWriteLock</div><div class="line">pool-1-thread-8--releaseWriteLock</div><div class="line">pool-1-thread-9--getWriteLock</div><div class="line">pool-1-thread-9--releaseWriteLock</div><div class="line">pool-1-thread-10--getWriteLock</div><div class="line">pool-1-thread-10--releaseWriteLock</div></pre></td></tr></table></figure>
<p>从结果中可以看出，在上一个线程完成自身的写操作之前，下一个线程是无法获得写锁并开始写入的。<br>将executorService.submit(writeTask)这行代码注释掉，去掉executorService.submit(readTask)的注释，重新运行程序对十个线程同时进行读操作进行测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">pool-1-thread-2--getReadLock</div><div class="line">pool-1-thread-7--getReadLock</div><div class="line">pool-1-thread-6--getReadLock</div><div class="line">pool-1-thread-8--getReadLock</div><div class="line">pool-1-thread-5--getReadLock</div><div class="line">pool-1-thread-1--getReadLock</div><div class="line">pool-1-thread-4--getReadLock</div><div class="line">pool-1-thread-3--getReadLock</div><div class="line">pool-1-thread-10--getReadLock</div><div class="line">pool-1-thread-9--getReadLock</div><div class="line">pool-1-thread-2--releaseReadLock</div><div class="line">pool-1-thread-3--releaseReadLock</div><div class="line">pool-1-thread-10--releaseReadLock</div><div class="line">pool-1-thread-7--releaseReadLock</div><div class="line">pool-1-thread-9--releaseReadLock</div><div class="line">pool-1-thread-4--releaseReadLock</div><div class="line">pool-1-thread-8--releaseReadLock</div><div class="line">pool-1-thread-1--releaseReadLock</div><div class="line">pool-1-thread-6--releaseReadLock</div><div class="line">pool-1-thread-5--releaseReadLock</div></pre></td></tr></table></figure>
<p>可以看出如果是读操作的话，读锁允许多个线程同时进入互斥区进行操作。<br>总结一下，如代码在get方法时候通过readWriteLock.readLock()获取了读锁，多个线程可以同时获取这读锁，set方法通过readWriteLock.writeLock()获取了写锁，同时只有一个线程可以获取写锁，其他线程在获取写锁时候会阻塞直到写锁被释放。假如一个线程已经获取了读锁，这时候如果一个线程要获取写锁时候要等待直到释放了读锁，如果一个线程获取了写锁，那么所有获取读锁的线程需要等待直到写锁被释放。所以相比synchronized来说运行多个读者同时存在，所以提高了并发量。<br>注意，需要使用者需要显式的调用Lock与Unlock操作。</p>
<h2 id="九-Volatile变量"><a href="#九-Volatile变量" class="headerlink" title="九.Volatile变量"></a>九.Volatile变量</h2><p>对于避免不可见性问题，Java还提供了一种弱形式的同步，即使用了<font color="#800000">volatile</font>关键字。该关键字<strong>确保了对一个变量的更新对其他线程可见</strong>。当一个变量被声明为volatile时候，线程写入时候不会把值缓存在寄存器或者或者在其他地方，当线程读取的时候会从主内存重新获取最新值，而不是使用当前线程的拷贝内存变量值。<br>volatile虽然提供了可见性保证，但是<strong>不能使用他来构建复合的原子性操作</strong>，也就是说当一个变量依赖其他变量或者更新变量值时候新值依赖当前老值时候不在适用。与synchronized相似之处在于如图：<br><img src="http://osio2xhqh.bkt.clouddn.com/image/png/sync-2.png?imageMogr2/thumbnail/!50p" alt="sync-2"><br>如图线程A修改了volatile变量b的值，然后线程B读取了改变量值，那么所有A线程在写入变量b值前可见的变量值，在B读取volatile变量b后对线程B都是可见的，图中线程B对A操作的变量a,b的值都可见的。volatile的内存语义和synchronized有类似之处，具体说是说当线程写入了volatile变量值就等价于线程退出synchronized同步块(会把写入到本地内存的变量值同步到主内存)，读取volatile变量值就相当于进入同步块(会先清空本地内存变量值，从主内存获取最新值)。<br>下面的Integer也是线程不安全的，因为没有进行同步措施。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class ThreadNotSafeInteger &#123;</div><div class="line"></div><div class="line">    private int value;</div><div class="line"></div><div class="line">    public int get() &#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">    public void set(int value) &#123;</div><div class="line">        this.value = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用synchronized关键字进行同步如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ThreadSafeInteger &#123;</div><div class="line"></div><div class="line">    private int value;</div><div class="line"></div><div class="line">    public synchronized int get() &#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized void set(int value) &#123;</div><div class="line">        this.value = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>等价于使用volatile进行同步如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class ThreadSafeInteger &#123;</div><div class="line"></div><div class="line">    private volatile int value;</div><div class="line"></div><div class="line">    public int get() &#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void set(int value) &#123;</div><div class="line">        this.value = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用synchronized和使用volatile是等价的，但是并不是所有情况下都是等价，一般只有满足下面所有条件才能使用volatile</p>
<ul>
<li>写入变量值时候不依赖变量的当前值，或者能够保证只有一个线程修改变量值。</li>
<li>写入的变量值不依赖其他变量的参与。</li>
<li>读取变量值时候不能因为其他原因进行加锁。</li>
</ul>
<p>另外，加锁可以同时保证可见性和原子性，而volatile只保证变量值的可见性。<br>注意，volatile关键字不会引起线程上下文切换和线程调度。另外volatile还用来解决重排序问题，在后面会讲到。</p>
<h2 id="十-乐观锁与悲观锁"><a href="#十-乐观锁与悲观锁" class="headerlink" title="十.乐观锁与悲观锁"></a>十.乐观锁与悲观锁</h2><h3 id="10-1-悲观锁"><a href="#10-1-悲观锁" class="headerlink" title="10.1 悲观锁"></a>10.1 悲观锁</h3><p><strong>悲观锁</strong>，指数据被外界修改持保守态度(悲观)，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制。数据库中实现是对数据记录进行操作前，先给记录加排它锁，如果获取锁失败，则说明数据正在被其他线程修改，则等待或者抛出异常。如果加锁成功，则获取记录，对其修改，然后事务提交后释放排它锁。<br>一个例子：select * from 表 where .. for update;<br>悲观锁是先加锁再访问策略，处理加锁会让数据库产生额外的开销，还有增加产生死锁的机会，另外在多个线程只读情况下不会产生数据不一致行问题，没必要使用锁，只会增加系统负载，降低并发性，因为当一个事务锁定了该条记录，其他读该记录的事务只能等待。</p>
<h3 id="10-2-乐观锁"><a href="#10-2-乐观锁" class="headerlink" title="10.2 乐观锁"></a>10.2 乐观锁</h3><p><strong>乐观锁</strong>是相对悲观锁来说的，它认为数据一般情况下不会造成冲突，所以在访问记录前不会加排他锁，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，具体说根据update返回的行数让用户决定如何去做。乐观锁并不会使用数据库提供的锁机制，一般在表添加version字段或者使用业务状态来做。<br>乐观锁直到提交的时候才去锁定，所以不会产生任何锁和死锁。</p>
<h2 id="十一-独占锁与共享锁"><a href="#十一-独占锁与共享锁" class="headerlink" title="十一.独占锁与共享锁"></a>十一.独占锁与共享锁</h2><p>根据锁能够被单个线程还是多个线程共同持有，锁又分为<strong>独占锁</strong>和<strong>共享锁</strong>。独占锁保证任何时候都只有一个线程能读写权限，ReentrantLock就是以独占方式实现的互斥锁。共享锁则可以同时有多个读线程，但最多只能有一个写线程，读和写是互斥的，例如ReadWriteLock读写锁，它允许一个资源可以被多线程同时进行读操作，或者被一个线程写操作，但两者不能同时进行。<br><strong>独占锁是一种悲观锁</strong>，每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据一致性，而独占锁只允许同时一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。<br><strong>共享锁是一种乐观锁</strong>，它放宽了加锁的条件，允许多个线程同时进行读操作。</p>
<h2 id="十二-公平锁与非公平锁"><a href="#十二-公平锁与非公平锁" class="headerlink" title="十二.公平锁与非公平锁"></a>十二.公平锁与非公平锁</h2><p>根据线程获取锁的抢占机制锁可以分为<strong>公平锁</strong>和<strong>非公平锁</strong>。</p>
<ul>
<li>公平锁表示线程获取锁的顺序是按照线程加锁的时间多少来决定的，也就是最早加锁的线程将最早获取锁，也就是先来先得的<strong>FIFO顺序</strong>。</li>
<li>而非公平锁则运行闯入，也就是先来不一定先得。  </li>
</ul>
<p>ReentrantLock提供了公平和非公平锁的实现：<br>公平锁 : ReentrantLock pairLock = new ReentrantLock(true);<br>非公平锁 : ReentrantLock unpairLock = new ReentrantLock(false);<br>如果构造函数不传递参数，则默认是非公平锁。<br>在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销。<br>假设线程A已经持有了锁，这时候线程B请求该锁将会被挂起，当线程A释放锁后，假如当前有线程C也需要获取该锁，如果采用非公平锁方式，则根据线程调度策略线程B和C两者之一可能获取锁，这时候不需要任何其他干涉，如果使用公平锁则需要把C挂起，让B获取当前锁。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://roronoa.space/2017/07/03/hexo-imgbed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="roronoa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="roronoa space">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/03/hexo-imgbed/" itemprop="url">
                  使用七牛云搭建Hexo博客图床
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-03T22:26:00+08:00">
                2017-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index">
                    <span itemprop="name">Hexo</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>转载自http://www.jianshu.com/p/ec2c8acf63cd
</code></pre><p>今天一打开blog发现一个重大问题，所有文章中的图片全挂了，Hexo文章中的图片，可以放在本地，然后和静态文件一起发布（部署）到空间里，原来就是这么做的。<br>经过后来的仔细想想，我觉得文章中以前一直都是用的本地图片，如果有一天我电脑不用了，或者转移或者在出现这种情况，每个图片不是还得重弄嘛，太费劲了，之前搭建博客的时候，看到了用七牛云存储来托管图片，这下迁移数据，加载什么的烦恼，都忘掉！！接下来，由此困扰的同学，可以直接看完。看完你会从建立账号到使用图片外链的技能，基础操作只需要这一篇博客就够用了。</p>
<h2 id="七牛简介"><a href="#七牛简介" class="headerlink" title="七牛简介"></a>七牛简介</h2><p>七牛云，在这里您可以方便快捷的访问您在七牛云中使用的各类资源，通过简单操作便可以完成对相关资源的配置监控和管理。<br>一句话，我就是用它做图片托管，取外链写在文章中。OK。  </p>
<h2 id="菜鸟阶段"><a href="#菜鸟阶段" class="headerlink" title="菜鸟阶段"></a>菜鸟阶段</h2><h3 id="初阶-注册与初识"><a href="#初阶-注册与初识" class="headerlink" title="初阶:注册与初识"></a>初阶:注册与初识</h3><p>首先需要申请七牛账号，访问<a href="https://portal.qiniu.com/signup?code=3ljtpdxtk87yq" target="_blank" rel="external">七牛云官网</a>，进到下面这个页面，里面有多种服务，当然你们需要可以自行解决需求，今天我们只讲图片要用到的。<br><img src="http://osio2xhqh.bkt.clouddn.com/image/png/hexo-imgbed1.png" alt="hexo-imgbed1"><br>看到图片中的服务了吧，现在只需要点击对象存储这个就可以创建空间了，然后在里面选择配置吧。<br><img src="http://osio2xhqh.bkt.clouddn.com/image/png/hexo-imgbed2.png" alt="hexo-imgbed2"><br>亲测没什么大碍，上面说“ 华北区域尚未支持自定义数据处理服务，一旦创建区域无法修改，请谨慎选择。 ”所以默默选择了华东，然后控制是我选的是公开的，私有的获取外链方式不一样后续介绍。好了，恭喜你，你已经完成了菜鸟任务。  </p>
<h2 id="中鸟阶段"><a href="#中鸟阶段" class="headerlink" title="中鸟阶段"></a>中鸟阶段</h2><h3 id="进阶-使用与相识"><a href="#进阶-使用与相识" class="headerlink" title="进阶:使用与相识"></a>进阶:使用与相识</h3><p>接下来，我们该使用强大的服务了。在内容管理中找到上传文件。<br><img src="http://osio2xhqh.bkt.clouddn.com/image/png/hexo-imgbed3.png" alt="hexo-imgbed3">  </p>
<p><img src="http://osio2xhqh.bkt.clouddn.com/image/png/hexo-imgbed4.png" alt="hexo-imgbed4"><br>然后就会进到上传的页面，选择文件，接下来都会啦。然后关闭后，回到了文件上传列表界面。<br><img src="http://osio2xhqh.bkt.clouddn.com/image/png/hexo-imgbed5.png" alt="hexo-imgbed5"><br>后面的复制外链点击后就可以了，然后回到md文件中只要写上图片语法就可以引用了。  </p>
<pre><code>![自己定义的图片名字](复制过来的外链）
</code></pre><p>这里注意还有一种<strong>高级用法</strong>，有时我们自己使用截图软件对自己在visio或者OminiGraffle上画的图截图并嵌入到markdown里面后，在网页里面往往会出现展示过大的情况。笔者就曾经被这个问题弄得无比头大，每次写博客都重新压一次图简直要死。好在七牛为我们提供了一个十分便捷的功能。可以参考下面两个链接：<br><a href="https://developer.qiniu.com/dora/manual/1279/basic-processing-images-imageview2" target="_blank" rel="external">图片基本处理</a><br><a href="https://developer.qiniu.com/dora/manual/1270/the-advanced-treatment-of-images-imagemogr2" target="_blank" rel="external">图片高级处理</a><br>通常的操作是对图片按原有比例进行缩放，我们有下面这样一张图片：<br><img src="http://osio2xhqh.bkt.clouddn.com/image/png/process1.png" alt="process1"><br>在markdown中的写法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![process1](http://osio2xhqh.bkt.clouddn.com/image/png/process1.png)</div></pre></td></tr></table></figure></p>
<p>下面使用七牛云的API对引用方式进行修改，添加缩放50%参数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![process1-thumb](http://osio2xhqh.bkt.clouddn.com/image/png/process1.png?imageMogr2/thumbnail/!50p)</div></pre></td></tr></table></figure></p>
<p>这时展示效果如下所示：<br><img src="http://osio2xhqh.bkt.clouddn.com/image/png/process1.png?imageMogr2/thumbnail/!50p" alt="process1-thumb"><br>是不是很炫酷！<br>OK了，这个时候你重新部署一下，看看是不是文章里已经有图片了呢，好处多多，不一一说明。那么中鸟就可以了，老鸟干什么？来吧！<br>注意：<br>七牛目前只支持一个请求上传一个文件，所以一次上传多个文件的话，就等同于一次发送多个请求，七牛不支持。</p>
<h2 id="老鸟阶段"><a href="#老鸟阶段" class="headerlink" title="老鸟阶段"></a>老鸟阶段</h2><h3 id="高阶-我要上天"><a href="#高阶-我要上天" class="headerlink" title="高阶:我要上天"></a>高阶:我要上天</h3><p>对于想弄懂深入的老鸟们，上述仅仅够用当然是不行的，来看看下面吧。<br>刚才说公开空间和私有空间的区别，对就在这：</p>
<ul>
<li>公开空间：<ol>
<li>直接在界面上获得链接（上述图片已经演示了）。</li>
<li>如果在给bucket绑定了域名的话，可以通过以下地址访问。<br><a href="http://domain/key" target="_blank" rel="external">http://domain/key</a></li>
</ol>
</li>
</ul>
<p>其中domain是bucket所对应的域名。七牛云为每一个bucket提供一个默认域名。用户也可以将自有的域名绑定到bucket上，通过自有域名访问七牛云,不过我没打算付费，所以“您的账户余额少于10元，暂无权限使用融合CDN，点击充值”，没办法使用自己的域名，不影响使用没必要了。key可理解为文件名，但可包含文件分隔符等其它字符。可参考：特殊key资源的访问。<br>注意： key必须采用utf8编码，如使用非utf8编码访问七牛云将反馈错误。</p>
<ul>
<li>私有空间：<br>  私有资源必须通过临时下载凭证(downloadToken)进行下载，如下：<pre><code>[GET] http://&lt;domain&gt;/&lt;key&gt;?e=&lt;deadline&gt;token=&lt;downloadToken&gt;
</code></pre>  注意，尖括号不是必需，代表替换项。  </li>
</ul>
<p>deadline 由服务器时间加上 指定秒数 表示过期时间点。默认 3600 秒，服务器时间需校准，不要与标准时间相差太大。 downloadToken 可以使用 SDK 提供的方法生成。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://roronoa.space/2017/07/02/operating_system_process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="roronoa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="roronoa space">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/02/operating_system_process/" itemprop="url">
                  关于操作系统我们应该知道些什么？--进程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-02T18:05:00+08:00">
                2017-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Operating-System/" itemprop="url" rel="index">
                    <span itemprop="name">Operating System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="What-is-process"><a href="#What-is-process" class="headerlink" title="What is process?"></a>What is process?</h2><p>最简单的定义：<strong><em>进程(Process)</em></strong>是<strong>程序(Application)</strong>的一次运行实例(Instance of an executing program)。所以进程有时也被称为任务(<font color="#800080">task</font>  or <font color="#800080">job</font>)。<br>操作系统的功能之一是代表上层应用访问和管理底层硬件。而这里所指的应用，仅表示保存在某处(硬盘，闪存，甚至是云)的程序代码，是一个<strong>静态实体(static entity)</strong>，如下图所示:<br><img src="http://osio2xhqh.bkt.clouddn.com/image/png/process1.png?imageMogr2/thumbnail/!50p" alt="static program entity"><br>当应用的程序代码被加载到内存，开始运行时，就生成了一个进程，所以进程是一个<strong>动态实体(active entity)</strong>。如果相同的应用被运行多次，那么就会对应的生成多个进程。每个进程都会执行相同的程序代码，但是运行状态各有不同，这进一步印证了进程是程序的一次运行实例。如下图所示：<br><img src="http://osio2xhqh.bkt.clouddn.com/image/png/process2.png?imageMogr2/thumbnail/!50p" alt="active process entity">  </p>
<h2 id="What-does-a-process-look-like"><a href="#What-does-a-process-look-like" class="headerlink" title="What does a process look like?"></a>What does a process look like?</h2><p><img src="http://osio2xhqh.bkt.clouddn.com/image/png/process3.png?imageMogr2/thumbnail/!50p" alt="process-structure">  </p>
<ul>
<li><em>text</em> : 程序代码。</li>
<li><em>data</em> : 进程第一次初始化时的有效数据。<br>text和data是进程首次加载时的静态状态，在运行之前就可以确定。</li>
<li><em>heap</em> : 运行时动态分配的内存空间(<strong>堆内存</strong>)。</li>
<li><em>special area</em> : 不允许进程访问的内存空间。</li>
<li><em>stack</em> : 以LIFO(后进先出，Last In First Out)规则管理的内存空间(<strong>栈内存</strong>)。可用来在执行过程切换时保存和恢复现场。</li>
</ul>
<p>进程占用的内存被称为<em>地址空间(address space)</em>。然而机器的内存大小总归是有限的，进程太多会导致物理内存空间不够用。并且让进程直接面向物理内存地址进行操作比较复杂，不同进程间地址空间的隔离性很差。为了避免这些问题，当处理器读或写入内存位置时，会使用<strong>虚拟地址(Virtual Address)</strong>，作为读或写操作的一部分，处理器同时会将虚拟地址转换为物理地址。这个转换往往是通过<strong>分页(Page)</strong>机制并配合一些策略来实现的。关于虚拟地址和内存管理的内容会在后续的博客中进行介绍，这里先有个大致印象。整体的映射关系可以见下图：<br><img src="http://osio2xhqh.bkt.clouddn.com/image/png/process4.png" alt="process-structure">  </p>
<h2 id="How-does-the-OS-know-what-a-process-is-doing"><a href="#How-does-the-OS-know-what-a-process-is-doing" class="headerlink" title="How does the OS know what a process is doing?"></a>How does the OS know what a process is doing?</h2><h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p>由于每个应用程序都是运行在某个进程的<em>上下文(Context)</em>中的。上下文是由程序正确运行所需的状态做成的。结合上文提到的进程占用内存空间的结构来看，这个状态包含存放在存储器中的程序的代码和数据，它的栈，通用目的寄存器的内容、程序计数器(PC,Program Counter)、环境变量以及打开文件描述符的集合等等。这些信息在操作系统中被一个称作<em>进程控制块(PCB,Process Control Block)</em>的结构体来统一管理，其结构如下图所示：<br><img src="http://osio2xhqh.bkt.clouddn.com/image/png/process5.png?imageMogr2/thumbnail/!50p" alt="process-structure"><br>PCB在进程创建并初始化的时候会生成。操作系统根据PCB来获知当前进程的运行状态，进而用于进程切换时保存和恢复现场。</p>
<h3 id="How-is-a-PCB-used"><a href="#How-is-a-PCB-used" class="headerlink" title="How is a PCB used?"></a>How is a PCB used?</h3><p><img src="http://osio2xhqh.bkt.clouddn.com/image/png/process6.png?imageMogr2/thumbnail/!50p" alt="process-structure"><br>在上图中可以看出，两个进程P1和P2在运行过程中都会载入自身的PCB。在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。这种决定就叫做<em>调度(schedule)</em>，是由内核中称为<em>调度器(scheduler)</em>的代码处理的，关于调度的问题这里不展开来谈。在内核调度了一个新的进程运行后，它就抢占当前进程，使用一种称作<em>上下文切换(Context Switch)</em>的机制来将控制转移到新的进程(实际上就是PCB信息的切换)，它包括：</p>
<ol>
<li>保存当前进程的上下文。</li>
<li>恢复某个先前被强占的进程被保存的上下文。</li>
<li>将控制传递给这个新恢复的进程。</li>
</ol>
<p>上下文切换是一种十分昂贵的操作，原因有下面两点。</p>
<ul>
<li>保存被抢占进程的PCB现场，并重新从抢占进程的PCB中恢复信息到内存和寄存器，这种save和load操作本身就会增加耗时。</li>
<li>间接影响是上下文切换会导致CPU的<em>高速缓存污染(Cache pollution)</em>。对于新的进程而言，上一个进程在CPU高速缓存中保存的信息是无效的。我们通常称这个时候高速缓存的状态会由<strong>hot</strong>变为<strong>cold</strong>，必须再次预热。由于CPU高速缓存的速度要成倍优于内存，所以频繁的上下文切换将会极大影响进程的执行效率。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://roronoa.space/2017/06/25/Java_concurrency_part_1_synchronizers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="roronoa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="roronoa space">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/25/Java_concurrency_part_1_synchronizers/" itemprop="url">
                  Java高级并发编程-Synchronizers
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-25T10:04:00+08:00">
                2017-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><em>Synchronizers(同步器)</em></strong>是用来调整和控制线程执行逻辑的类。Java Concurrency Utilities framework提供了其多种实现包括semaphore, cyclic barrier, countdown latch, exchanger和phaser synchronizers. 下面我将对每种同步器的功能进行介绍并演示在代码中是如何使用的。</p>
<h2 id="Semaphores-信号量"><a href="#Semaphores-信号量" class="headerlink" title="Semaphores(信号量)"></a>Semaphores(信号量)</h2><p><a href="http://www.javaworld.com/article/2077413/learn-java/semaphore.html" target="_blank" rel="external"><em>semaphore</em></a>是一种线程同步工具，用来控制多线程对共享资源的访问。信号量常见的使用方法是被声明为一个protected变量，其值通过使用<em>acquire</em>操作自增，通过<em>release</em>操作自减。<br>acquire操作会导致两种情况，一是直接将共享资源的控制权交给调用该方法的线程，二是自增后发现信号量的值达到预设限制，此时会阻塞调用线程的执行。release操作会对信号量的值进行自减，同时唤醒被阻塞的线程。<br>值能超过1的信号量被称作<a href="http://www.javaworld.com/article/2076843/core-java/programming-java-threads-in-the-real-world--part-4.html" target="_blank" rel="external">counting semaphores(计数信号量)</a>，值只能取0或1的信号量被称作<em>binary semaphores(二进制信号量)</em>或<a href="http://www.javaworld.com/article/2076815/core-java/programming-java-threads-in-the-real-world--part-3.html" target="_blank" rel="external">mutexes(互斥器)</a>。且信号量的值永远不能为负数。<br>类<font color="#800000">java.lang.concurrent.Semaphore</font>提供了满足上述语义的计数信号量实现。在类中提供了两种构造方法：<font color="#800000">Semaphore(int permits)</font>和<font color="#800000">Semaphore(int permits, boolean fair)</font>。参数中的<em>permits(许可数)</em>表示该信号量允许同时通过的线程数。参数<em>fair</em>设置为<font color="#800000">false</font>时，此类不对线程获取许可的顺序做任何保证，亦即抢占是被允许的。也就是说可以在已经等待的线程前为调用<font color="#800000">acquire()</font>的线程分配一个许可，从逻辑上说，就是新线程将自己置于等待线程队列的头部。当fair设置为<font color="#800000">true</font>时，信号量保证对于任何调用获取方法的线程而言，都按照处理它们调用这些方法的顺序(即先进先出；FIFO)来选择线程、获得许可。</p>
<h3 id="Working-with-semaphores"><a href="#Working-with-semaphores" class="headerlink" title="Working with semaphores"></a>Working with semaphores</h3><p>在实际应用中，Semaphores经常被用来限制同时访问某一公共资源的线程数。下面这段代码演示了使用信号量对多线程访问字符串常量池进行控制的一个例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Pool pool = <span class="keyword">new</span> Pool();</div><div class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                String name = Thread.currentThread().getName();</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                        String item;</div><div class="line">                        System.out.printf(<span class="string">"%s acquiring %s%n"</span>, name, item = pool.getItem());</div><div class="line">                        Thread.sleep(<span class="number">200</span> + (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>));</div><div class="line">                        System.out.printf(<span class="string">"%s putting back %s%n"</span>, name, item);</div><div class="line">                        pool.putItem(item);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    System.out.printf(<span class="string">"%s interrupted%n"</span>, name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        ExecutorService[] executors = <span class="keyword">new</span> ExecutorService[Pool.MAX_AVAILBLE + <span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; executors.length; i++) &#123;</div><div class="line">            executors[i] = Executors.newSingleThreadExecutor();</div><div class="line">            executors[i].execute(r);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILBLE = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILBLE, <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">private</span> String[] items;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILBLE];</div><div class="line"></div><div class="line">    Pool() &#123;</div><div class="line">        items = <span class="keyword">new</span> String[MAX_AVAILBLE];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</div><div class="line">            items[i] = <span class="string">"ITEM"</span> + i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        available.acquire();</div><div class="line">        <span class="keyword">return</span> getNextAvailableItem();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putItem</span><span class="params">(String item)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (markAsUnused(item))</div><div class="line">            available.release();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> String <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILBLE; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!used[i]) &#123;</div><div class="line">                used[i] = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">return</span> items[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// not reached</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(String item)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILBLE; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (item == items[i]) &#123;</div><div class="line">                <span class="keyword">if</span> (used[i]) &#123;</div><div class="line">                    used[i] = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125; <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，声明了多个Executor，每个Executor包含有一个工作线程循环的从字符串常量池中获取字符串，并在一段时间后释放对已获取字符串的控制权。<br>类<font color="#800000">Pool</font>提供了<font color="#800000">String getItem()</font>和<font color="#800000">void putItem(String item)</font>方法用来获取和交还资源。在调用<font color="#800000">getItem()</font>获取一个字符串之前，线程必须先通过信号量获得一个许可，许可能够保证当前还有剩余的可用资源。当线程的工作完成后，会调用<font color="#800000">putItem(String)</font>释放对资源的控制权，将字符串交还回常量池中。同时还会释放信号量的一个许可，唤醒另外阻塞的线程获取资源。<br>方法<font color="#800000">String getNextAvailableItem()</font>和<font color="#800000">boolean markAsUnused(String item)</font>被synchronized修饰，用来维护常量池状态的一致性。<br>这个例子的运行结果如下所示(每次运行都可能会有不同结果):  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">pool-1-thread-1 acquiring ITEM0</div><div class="line">pool-10-thread-1 acquiring ITEM9</div><div class="line">pool-9-thread-1 acquiring ITEM8</div><div class="line">pool-8-thread-1 acquiring ITEM7</div><div class="line">pool-7-thread-1 acquiring ITEM6</div><div class="line">pool-6-thread-1 acquiring ITEM5</div><div class="line">pool-5-thread-1 acquiring ITEM4</div><div class="line">pool-4-thread-1 acquiring ITEM3</div><div class="line">pool-3-thread-1 acquiring ITEM2</div><div class="line">pool-2-thread-1 acquiring ITEM1</div><div class="line">pool-1-thread-1 putting back ITEM0</div><div class="line">pool-11-thread-1 acquiring ITEM0</div><div class="line">pool-2-thread-1 putting back ITEM1</div><div class="line">pool-1-thread-1 acquiring ITEM1</div><div class="line">pool-3-thread-1 putting back ITEM2</div><div class="line">pool-2-thread-1 acquiring ITEM2</div><div class="line">pool-7-thread-1 putting back ITEM6</div><div class="line">pool-3-thread-1 acquiring ITEM6</div><div class="line">pool-9-thread-1 putting back ITEM8</div></pre></td></tr></table></figure>
<p>在输出中可以看出，11个线程对十个共享资源进行竞争。当线程pool-11-thread-1尝试获取资源时，由于信号量的许可数量已经达到上界十个，所以会被阻塞。在pool-1-thread-1释放ITEM0之后，信号量能够发放新的许可，此时pool-11-thread-1获取许可，从常量池中拿到ITEM0并从阻塞状态变为运行状态。</p>
<h2 id="Cyclic-barriers-循环栅栏"><a href="#Cyclic-barriers-循环栅栏" class="headerlink" title="Cyclic barriers(循环栅栏)"></a>Cyclic barriers(循环栅栏)</h2><p><a href="http://www.javaworld.com/article/2078002/java-concurrency/java-concurrency-with-thread-gates.html" target="_blank" rel="external"><em>Cyclic barrier(循环栅栏)</em></a>是一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点(common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时CyclicBarrier很有用。因为该barrier在释放等待线程后可以重用，所以称它为“循环”的barrier。<br>类<font color="#800000">java.lang.concurrent.CyclicBarrier</font>循环栅栏的实现类，提供了下面两种构造方法:</p>
<ul>
<li><font color="#800000">CyclicBarrier(int nthreads, Runnable barrierAction)</font>创建一个新的CyclicBarrier，它将在给定数量(nthreads)的参与者(线程)处于等待状态时启动，并在启动barrier时执行给定的屏障操作，该操作由最后一个进入 barrier的线程执行。</li>
<li><font color="#800000">CyclicBarrier(int nthreads)</font>创建一个新的CyclicBarrier，它将在给定数量的参与者(线程)处于等待状态时启动，但它不会在启动barrier时执行预定义的操作。</li>
</ul>
<p>类<font color="#800000">CyclicBarrier</font>声明了一个<font color="#800000">int await()</font>方法，在所有参与者都已经在此barrier上调用await方法之前，调用该方法将一直等待。即如果当前线程不是将到达的最后一个线程，出于调度目的，将禁用它，且在发生以下情况之一前，该线程将一直处于休眠状态：</p>
<ul>
<li>最后一个线程到达；或者</li>
<li>其他某个线程中断当前线程；或者</li>
<li>其他某个线程中断另一个等待线程；或者</li>
<li>其他某个线程在等待 barrier 时超时；或者</li>
<li>其他某个线程在此 barrier 上调用 reset()。</li>
</ul>
<p>如果当前线程：</p>
<ul>
<li>在进入此方法时已经设置了该线程的中断状态；或者</li>
<li>在等待时被中断</li>
</ul>
<p>则抛出<font color="#800000">InterruptedException</font>，并且清除当前线程的已中断状态。<br>如果在线程处于等待状态时barrier被<font color="#800000">reset()</font>，或者在调用await时barrier被损坏，抑或任意一个线程正处于等待状态，则抛出<font color="#800000">BrokenBarrierException</font>异常。<br>如果任何线程在等待时被中断，则其他所有等待线程都将抛出<font color="#800000">BrokenBarrierException</font>异常，并将barrier置于损坏状态。<br>如果当前线程是最后一个将要到达的线程，并且构造方法中提供了一个非空的屏障操作，则在允许其他线程继续运行之前，当前线程将运行该操作。如果在执行屏障操作过程中发生异常，则该异常将传播到当前线程中，并将barrier置于损坏状态。</p>
<h3 id="Working-with-cyclic-barriers"><a href="#Working-with-cyclic-barriers" class="headerlink" title="Working with cyclic barriers"></a>Working with cyclic barriers</h3><p>Cyclic barriers可以用来将计算耗费型的工作拆分成多个独立任务分别计算。同样也可以用在多人游戏当中，直到最后一个玩家加入后游戏才能够开始。具体见下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Runnable action = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                String name = Thread.currentThread().getName();</div><div class="line">                System.out.printf(<span class="string">"Thread %s executing barrier action.%n"</span>, name);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">final</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, action);</div><div class="line">        Runnable task = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                String name = Thread.currentThread().getName();</div><div class="line">                System.out.printf(<span class="string">"%s about to join game...%n"</span>, name);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    barrier.await();</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    System.out.println(<span class="string">"thread interrupted"</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</div><div class="line">                    System.out.println(<span class="string">"barrier is broken"</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                System.out.printf(<span class="string">"%s has joined game%n"</span>, name);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        ExecutorService[] executors = <span class="keyword">new</span> ExecutorService[]&#123;</div><div class="line">                Executors.newSingleThreadExecutor(),</div><div class="line">                Executors.newSingleThreadExecutor(),</div><div class="line">                Executors.newSingleThreadExecutor()</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">for</span> (ExecutorService executor : executors) &#123;</div><div class="line">            executor.execute(task);</div><div class="line">            executor.shutdown();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码的执行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pool-1-thread-1 about to join game...</div><div class="line">pool-3-thread-1 about to join game...</div><div class="line">pool-2-thread-1 about to join game...</div><div class="line">Thread pool-2-thread-1 executing barrier action.</div><div class="line">pool-2-thread-1 has joined game</div><div class="line">pool-3-thread-1 has joined game</div><div class="line">pool-1-thread-1 has joined game</div></pre></td></tr></table></figure>
<p>从执行结果中可以看出，游戏的三个参与者，pool-1-thread-1和pool-3-thread-1首先加入游戏，但因为此时并未达到barrier指定的参与数，所以在调用<font color="#800000">barrier.await()</font>会阻塞住。直到参与者pool-2-thread-1加入游戏后才会继续执行。同时，当最后一个参与者进入游戏后，指定的action操作会被触发。</p>
<h2 id="Countdown-latches-计数器"><a href="#Countdown-latches-计数器" class="headerlink" title="Countdown latches(计数器)"></a>Countdown latches(计数器)</h2><p><em>Countdown latch</em>是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。<br>类<font color="#800000">java.util.concurrent.CountDownLatch</font>提供一个包含初始计数的构造器<font color="#800000">CountDownLatch(int count)</font>。在当前计数到达零之前，调用其<font color="#800000">await()</font>方法会一直受阻塞。之后，会释放所有等待的线程，<font color="#800000">await()</font>的所有后续调用都将立即返回。<br>CountDownLatch有很多用途。可以将计数1初始化的CountDownLatch用作一个简单的开/关锁存器，或入口：在通过调用<font color="#800000">countDown()</font>的线程打开入口前，所有调用<font color="#800000">await()</font>的线程都一直在入口处等待。用N初始化的 CountDownLatch可以使一个线程在 N 个线程完成某项操作之前一直等待，或者使其在某项操作完成N次之前一直等待。</p>
<h3 id="Working-with-countdown-latches"><a href="#Working-with-countdown-latches" class="headerlink" title="Working with countdown latches"></a>Working with countdown latches</h3><p>Countdown latches决定了其十分适合用来做任务分解，步骤如下：  </p>
<ul>
<li>主线程创建一个计数为1的countdown latch(不妨称之为startLatch)作为一个开关锁存器，用来同时启动一组工作线程。</li>
<li>每个工作线程的run方法中都会先在startLatch上执行<font color="#800000">await()</font>方法，当所有工作线程就绪之后，主线程会对startLatch减1，允许工作线程开始执行自己的子任务。</li>
<li>与此同时，主线程会在另一个countdown latch上执行<font color="#800000">await()</font>(不妨称之为doneLatch)，该latch被初始化计数为子工作线程的数目。亦即当所有工作线程完成自身的任务之前主线程不会退出。</li>
<li>当一个工作线程任务结束后，会将doneLatch的计数减1。当其计数到达0后(意味着所有的工作线程都执行完毕)，主线程从阻塞状态变为运行状态，收集工作线程的结果并继续运行。</li>
</ul>
<p>下面就来看一个遵循该步骤编写的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">3</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123; <span class="comment">// create and start threads</span></div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(doneSignal, startSignal)).start();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"about to let threads proceed"</span>);</div><div class="line">        startSignal.await(); <span class="comment">// let all threads proceed</span></div><div class="line">        System.out.println(<span class="string">"doing work"</span>);</div><div class="line">        System.out.println(<span class="string">"waiting for threads to finish"</span>);</div><div class="line">        doneSignal.await(); <span class="comment">// wait for all threads to finish</span></div><div class="line">        System.out.println(<span class="string">"main thread terminating"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(CountDownLatch doneSignal, CountDownLatch startSignal)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</div><div class="line">        <span class="keyword">this</span>.startSignal = startSignal;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String name = Thread.currentThread().getName();</div><div class="line">            startSignal.await();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">                System.out.printf(<span class="string">"thread %s is working%n"</span>, name);</div><div class="line">                Thread.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">300</span>));</div><div class="line">                System.out.printf(<span class="string">"thread %s finishing%n"</span>, name);</div><div class="line">                doneSignal.countDown();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            System.out.println(<span class="string">"interrupted"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">about to let threads proceed</div><div class="line">doing work</div><div class="line">waiting for threads to finish</div><div class="line">thread Thread-0 is working</div><div class="line">thread Thread-1 is working</div><div class="line">thread Thread-2 is working</div><div class="line">thread Thread-2 is working</div><div class="line">thread Thread-2 is working</div><div class="line">thread Thread-0 is working</div><div class="line">thread Thread-2 is working</div><div class="line">thread Thread-1 is working</div><div class="line">thread Thread-2 is working</div><div class="line">thread Thread-0 is working</div><div class="line">thread Thread-2 finishing</div><div class="line">thread Thread-1 is working</div><div class="line">thread Thread-0 is working</div><div class="line">thread Thread-0 is working</div><div class="line">thread Thread-0 finishing</div><div class="line">thread Thread-1 is working</div><div class="line">thread Thread-1 is working</div><div class="line">thread Thread-1 finishing</div><div class="line">main thread terminating</div></pre></td></tr></table></figure>
<p>可以看到，startSignal用来控制所有子线程工作的开始。doneSignal负责保证当所有的子工作线程都完成自身的工作后，主线程才会继续执行。</p>
<h2 id="Exchanger-交换器"><a href="#Exchanger-交换器" class="headerlink" title="Exchanger(交换器)"></a>Exchanger(交换器)</h2><p><em>Exchanger</em>是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据， 如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。<br>类<font color="#800000">java.util.concurrent.Exchanger&lt;V&gt;</font>提供了一个初始化交换器的构造方法<font color="#800000">Exchanger()</font>并提供了两个<font color="#800000">exchange()</font>方法用来处理交换动作。如果两个线程有一个没有到达<font color="#800000">exchange()</font>方法，则会一直等待,如果担心有特殊情况发生，避免一直等待，可以使用<font color="#800000">exchange(V x, long timeout, TimeUnit unit)</font>设置最大等待时长。  </p>
<h3 id="Working-with-exchangers"><a href="#Working-with-exchangers" class="headerlink" title="Working with exchangers"></a>Working with exchangers</h3><p>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。同时Exchanger也可以用来设计pipeline，一个线程填充自己的缓冲区，另一个线程清空自己的缓冲区。当两个线程到达交换点后，会交换两者的缓冲区内容，如下面这段代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerDemo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> Exchanger&lt;DataBuffer&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</div><div class="line">    <span class="keyword">static</span> DataBuffer initialEmptyBuffer = <span class="keyword">new</span> DataBuffer();</div><div class="line">    <span class="keyword">static</span> DataBuffer initialFullBuffer = <span class="keyword">new</span> DataBuffer(<span class="string">"ITEM"</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">FillingLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                DataBuffer currentBuffer = initialEmptyBuffer;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                        addToBuffer(currentBuffer);</div><div class="line">                        <span class="keyword">if</span> (currentBuffer.isFull()) &#123;</div><div class="line">                            System.out.println(<span class="string">"filling loop thread wants to exchange"</span>);</div><div class="line">                            currentBuffer = exchanger.exchange(currentBuffer);</div><div class="line">                            System.out.println(<span class="string">"filling loop thread observes an exchange"</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    System.out.println(<span class="string">"filling loop thread interrupted"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">addToBuffer</span><span class="params">(DataBuffer buffer)</span> </span>&#123;</div><div class="line">                String item = <span class="string">"NEWITEM"</span> + count++;</div><div class="line">                System.out.printf(<span class="string">"Adding %s%n"</span>, item);</div><div class="line">                buffer.add(item);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">EmptyingLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                DataBuffer currentBuffer = initialFullBuffer;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                        takeFromBuffer(currentBuffer);</div><div class="line">                        <span class="keyword">if</span> (currentBuffer.isEmpty()) &#123;</div><div class="line">                            System.out.println(<span class="string">"emptying loop thread wants to exchange"</span>);</div><div class="line">                            currentBuffer = exchanger.exchange(currentBuffer);</div><div class="line">                            System.out.println(<span class="string">"emptying loop thread observes an exchange"</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    System.out.println(<span class="string">"emptying loop thread interrupted"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">takeFromBuffer</span><span class="params">(DataBuffer buffer)</span> </span>&#123;</div><div class="line">                System.out.printf(<span class="string">"taking %s%n"</span>, buffer.remove());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> EmptyingLoop()).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> FillingLoop()).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBuffer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</div><div class="line">    <span class="keyword">private</span> List&lt;String&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    DataBuffer() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    DataBuffer(String prefix) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</div><div class="line">            String item = prefix + i;</div><div class="line">            System.out.printf(<span class="string">"Adding %s%n"</span>, item);</div><div class="line">            items.add(item);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isFull())</div><div class="line">            items.add(s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> items.size() == <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> items.size() == MAX;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!isEmpty())</div><div class="line">            <span class="keyword">return</span> items.remove(<span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上段代码中，当填充线程的<font color="#800000">currentBuffer.isFull()</font>为true时，会执行<font color="#800000">currentBuffer = exchanger.exchange(currentBuffer)</font>并阻塞。由于initialFullBuffer在初始化时会填充十个数据，所以清空线程会先运行一段时间，直到<font color="#800000">currentBuffer.isEmpty()</font>为true时，执行<font color="#800000">exchanger.exchange()</font>，此时两个线程会交换彼此的缓存区。<br>程序的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">Adding ITEM0</div><div class="line">Adding ITEM1</div><div class="line">Adding ITEM2</div><div class="line">Adding ITEM3</div><div class="line">Adding ITEM4</div><div class="line">Adding ITEM5</div><div class="line">Adding ITEM6</div><div class="line">Adding ITEM7</div><div class="line">Adding ITEM8</div><div class="line">Adding ITEM9</div><div class="line">taking ITEM0</div><div class="line">taking ITEM1</div><div class="line">taking ITEM2</div><div class="line">taking ITEM3</div><div class="line">taking ITEM4</div><div class="line">taking ITEM5</div><div class="line">taking ITEM6</div><div class="line">taking ITEM7</div><div class="line">taking ITEM8</div><div class="line">taking ITEM9</div><div class="line">Adding NEWITEM0</div><div class="line">emptying loop thread wants to exchange</div><div class="line">Adding NEWITEM1</div><div class="line">Adding NEWITEM2</div><div class="line">Adding NEWITEM3</div><div class="line">Adding NEWITEM4</div><div class="line">Adding NEWITEM5</div><div class="line">Adding NEWITEM6</div><div class="line">Adding NEWITEM7</div><div class="line">Adding NEWITEM8</div><div class="line">Adding NEWITEM9</div><div class="line">filling loop thread wants to exchange</div><div class="line">filling loop thread observes an exchange</div><div class="line">Adding NEWITEM10</div><div class="line">emptying loop thread observes an exchange</div><div class="line">taking NEWITEM0</div><div class="line">Adding NEWITEM11</div><div class="line">Adding NEWITEM12</div><div class="line">Adding NEWITEM13</div><div class="line">Adding NEWITEM14</div><div class="line">Adding NEWITEM15</div><div class="line">Adding NEWITEM16</div><div class="line">taking NEWITEM1</div><div class="line">Adding NEWITEM17</div><div class="line">taking NEWITEM2</div><div class="line">Adding NEWITEM18</div><div class="line">taking NEWITEM3</div><div class="line">Adding NEWITEM19</div><div class="line">filling loop thread wants to exchange</div><div class="line">taking NEWITEM4</div><div class="line">taking NEWITEM5</div><div class="line">taking NEWITEM6</div><div class="line">taking NEWITEM7</div><div class="line">taking NEWITEM8</div><div class="line">taking NEWITEM9</div><div class="line">emptying loop thread wants to exchange</div><div class="line">emptying loop thread observes an exchange</div><div class="line">filling loop thread observes an exchange</div><div class="line">taking NEWITEM10</div><div class="line">Adding NEWITEM20</div><div class="line">taking NEWITEM11</div><div class="line">taking NEWITEM12</div></pre></td></tr></table></figure>
<h2 id="Phasers-移相器"><a href="#Phasers-移相器" class="headerlink" title="Phasers(移相器)"></a>Phasers(移相器)</h2><p><em>Phasers</em>的作用类似于<em>Cyclic barrier</em>，能够让一组线程在一个屏障点等待，直到组内最后一个线程到达屏障点之后在进行后续处理，同Cyclic barrier，Phasers也允许最后一个线程到达后触发自定义action。除此之外，Phasers能提供更加灵活的功能。<br>与Cyclic barrier只能操作固定数目线程(在初始化的构造函数中指定同步者的个数，且运行时无法再次调整)不同的是，Phasers能够处理可变数量的线程。线程能够随时<strong>注册</strong>到phaser上。为了实现这种机制，需要借助两个概念：phases和phase numbers。<br><em>phase</em>即指Phaser的当前状态，它是被一个整形数字phase number所标识的。当最后一个注册线程到达屏障点(<em>phaser barrier</em>)之后，Phaser就会进入下一个phase，并且其phase number会自增1(phase直译的话是相位，类比正弦函数，角度每增加2pi便会向前平移一个相位。以此来做类比还是比较好理解的)。<br>在Phaser中，多个线程协作执行的任务会划分为多个阶段，编程时需要明确各个阶段的任务，每个阶段都可以有任意个参与者，线程都可以随时注册并参与到某个阶段。<br>类<font color="#800000">java.util.concurrent.Phaser</font>作为Phaser的实现，其说明在对应的JavaDoc中已经十分详细，这里仅对几个重要的方法进行介绍。</p>
<ul>
<li>构造器<font color="#800000">Phaser(int threads)</font>会创建一个初始注册n个线程的Phaser，n即为在公共屏障点等待的线程数，如果不设定的话默认值为0。</li>
<li>方法<font color="#800000">int register()</font>提供向Phaser注册新线程的功能。</li>
<li>方法<font color="#800000">arrive()</font>在某个参与者完成任务后调用。</li>
<li>方法<font color="#800000">arriveAndDeregister()</font>，任务完成，取消自己的注册。</li>
<li>方法<font color="#800000">arriveAndAwaitAdvance()</font>，自己完成等待其他参与者完成，进入阻塞，直到Phaser成功进入下个阶段。</li>
</ul>
<h3 id="Working-with-phasers"><a href="#Working-with-phasers" class="headerlink" title="Working with phasers"></a>Working with phasers</h3><p>由于笔者用这个确实比较少，具体的例子可以参考<a href="http://www.cnblogs.com/chenssy/p/4989515.html" target="_blank" rel="external">【Java并发编程实战】—–“J.U.C”：Phaser</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://roronoa.space/2017/06/23/Java_concurrency_part_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="roronoa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="roronoa space">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/23/Java_concurrency_part_1/" itemprop="url">
                  Java高级并发编程-Executor
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-23T20:02:00+08:00">
                2017-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着多线程应用开发与日俱增的复杂性，许多开发者发现Java的底层并发机制已经不能够满足他们的需求。在这种情况下，是时候对java.util.concurrent包提供的功能进行全面的探索了。这其中包括Executor框架，Synchronizer类型，以及Java并发集合等等。<br>Java平台提供了底层的并发编程功能，能够为开发者提供多线程同步执行的能力。标准的Java多线程是存在一些缺陷的，比如：  </p>
<ol>
<li>Java底层的并发原语(<font color="#800000">synchronized</font>,<font color="#800000">volatile</font>, <font color="#800000">wait()</font>, <font color="#800000">notify()</font>, 和<font color="#800000">notifyAll()</font>)很难被正确的使用。因为错误使用这些原语导致出现的一些如线程死锁，线程饥饿，竞态等问题，也很难复现和排查。</li>
<li>多线程同步访问公共资源很容易成为应用性能的瓶颈点，影响应用的可扩展性，而这往往是许多现代应用的刚需。</li>
<li>Java提供的基础多线程编程功能太过于底层，开发者往往需要使用更高层次的抽象比如信号量和线程池，然而这些Java底层并没有提供。由此而引发的就是开发者需要自行构建上述抽象，而这往往十分浪费时间并且容易出现问题。</li>
</ol>
<p>正因为以上这些问题，<a href="https://www.jcp.org/en/jsr/detail?id=166" target="_blank" rel="external">JSR 166: Concurrency Utilities framework</a>在2002年被首次提出了，其设计的目的是用来为开发者提供高层次的并发编程能力。2年后也就是2004年，该框架在Java 5中被正式实现，并且在后续的版本中进行了逐步的完善。<br>本系列文章的目的是向开发者介绍Java Concurrency Utilities中的内容。在第一部分，会首先对该并发框架进行一个概览，并对Executor框架，synchronizer工具包，以及Java并发集合(Concurrent Collections)进行介绍。</p>
<h2 id="走进Java-Concurrency-Utilities"><a href="#走进Java-Concurrency-Utilities" class="headerlink" title="走进Java Concurrency Utilities"></a>走进Java Concurrency Utilities</h2><p><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/concurrency/" target="_blank" rel="external">Java Concurrency Utilities framework</a>是由一些专门设计用来构造多线程并发程序的<a href="http://www.javaworld.com/article/2074906/core-java/thanks-type-and-gentle-class.html" target="_blank" rel="external">类</a>所组成的。框架中所有的类都是线程安全的，并且都经过完善的测试，能够保障高性能。<br>Java Concurrency Utilities中的类型被组织成几个小的框架，从包命名上可以区分为Executor framework, synchronizer, concurrent collections, locks, atomic variables和Fork/Join。它们进一步又被细分为一个主package和一系列子package：</p>
<ul>
<li><strong>java.util.concurrent</strong>包含一些在并发编程中常用的工具类。例子包括semaphores, barriers, thread pools和concurrent hashmaps。  <ul>
<li><strong>java.util.concurrent.atomic</strong>包含一些底层的并发工具类，能够支持单变量的无锁化线程安全机制。</li>
<li><strong>java.util.concurrent.locks</strong>提供了一些不同于底层synchronization和monitors的加锁和临界区资源等待的工具类。</li>
</ul>
</li>
</ul>
<p>Java Concurrency Utilities框架同时也暴露了底层的compare-and-swap (CAS)硬件指令，其变体能够被大多数现代处理器所支持。CAS同时比基于Java monitor的同步机制更加轻量级，能够用来实现一些可以高度可扩展的并发工具类。基于CAS的<font color="#800000">java.util.concurrent.locks.ReentrantLock</font>类(可重入锁)，能够获得比<font color="#800000">synchronized</font>更好的性能。ReentrantLock同时能够提供更为可控的加锁机制。(在第二部分我会更为详细的讲解CAS是如何在<font color="#800000">java.util.concurrent</font>当中工作的)。</p>
<blockquote>
<p><strong>System.nanoTime()</strong></p>
<p>Java Concurrency Utilities框架包含返回long类型时间戳的<font color="#800000">nanoTime()</font>方法。这个方法能够保证纳秒级别的精度，可以用来做时间测定。</p>
</blockquote>
<p>在下面的几个部分中，我将依次介绍Java Concurrency Utilities中的三个实用特性。首先会解释为什么这些特性对现代并发编程如此重要，之后会演示这些工具类是如何工作的，是如何提升Java并发程序的运行速度，可靠性，工作效率和可扩展性的。  </p>
<h3 id="The-Executor-framework"><a href="#The-Executor-framework" class="headerlink" title="The Executor framework"></a>The Executor framework</h3><p>In threading, a task is a unit of work. One problem with low-level threading in Java is that task submission is tightly coupled with a task-execution policy, as demonstrated by Listing 1.<br>在多线程编程中，我们将task称为一个工作单元。Java底层并发机制的问题在于task的提交与task的执行是强相关的，就如下面这段代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</div><div class="line">            Runnable r = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    doWork(socket);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            <span class="keyword">new</span> Thread(r).start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Socket socket)</span> </span>&#123;</div><div class="line">        <span class="comment">// do some work with socket</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码描述了一个简单的服务器应用是如何运行的。服务器线程在一个死循环当中重复的在指定端口上调用<font color="#800000">socket.accept()</font>方法(注意该方法是阻塞式的)来接收客户端发送过来的请求，在接收到请求之后，服务器会启动一个线程来对该请求做进一步的处理。<br>因为示例代码中的应用为每一个请求都会新建一个线程来处理，当有大量请求到达服务器时，其无法对线程数目进行控制。由于每个创建出来的线程都会占用一定的内存，过多的线程会耗尽系统的可用内存，使应用异常终止。<br>上述问题可以通过改变task的执行策略来解决。相比于每次请求都新建一个线程来处理，使用线程池往往被认为是更好的方式。对于接受到的请求，线程池能够控制固定数目的线程来处理，避免了线程无限增长的情况。之后我们会使用<font color="#800000">java.util.concurrent</font>中提供的工具类来重写上面这段代码。  </p>
<p><font color="#800000">java.util.concurrent</font>包中包含了<a href="http://www.javaworld.com/article/2071822/java-concurrency/book-excerpt--executing-tasks-in-threads.html" target="_blank" rel="external">Executor framework</a>，一个专门用来解耦任务提交和任务执行策略的框架。利用该包提供的功能，我们可以十分方便的调整程序的任务执行策略，并且只需要对代码进行一些细微的改动。</p>
<h3 id="Inside-the-Executor-framework"><a href="#Inside-the-Executor-framework" class="headerlink" title="Inside the Executor framework"></a>Inside the Executor framework</h3><p>Executor framework基于<font color="#800000">Executor</font>接口，实现该接口的类被认为有能力执行<font color="#800000">java.lang.Runnable</font>任务。其中仅仅提供了一个需要实现的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Executes the given command at some time in the future.  The command</div><div class="line"> * may execute in a new thread, in a pooled thread, or in the calling</div><div class="line"> * thread, at the discretion of the &#123;<span class="doctag">@code</span> Executor&#125; implementation.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> command the runnable task</div><div class="line"> * <span class="doctag">@throws</span> RejectedExecutionException if this task cannot be</div><div class="line"> * accepted for execution</div><div class="line"> * <span class="doctag">@throws</span> NullPointerException if command is null</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</div></pre></td></tr></table></figure>
<p>提交一个Runnable任务的方式就是将其作为参数传入execute方法。如果executor由于一些原因不能执行任务(比如已经shut down了)，那么该方法会抛出一个<font color="#800000">RejectedExecutionException</font>异常。<br>Executor接口定义的关键点在于任务提交和任务执行策略的解耦。解耦之后Runnable任务能够根据开发者的需求实现多种执行策略，比如新建一个线程，使用线程池，或者使用Callable(后续会介绍)等等。<br>注意，仅仅定义一个Executor接口是非常有局限性的。你不能终止一个executor的运行，不能判断一个异步任务是否执行结束，同时你也不能取消一个正在运行的任务。基于以上几点缺陷，Executor framework另外提供了一个<font color="#800000">ExecutorService</font>接口，它是继承自Executor接口的。<br>在ExecutorService提供的方法中，有下面五个值得注意的：</p>
<ul>
<li><strong>boolean awaitTermination(long timeout, TimeUnit unit)</strong>三种情况会使Executor阻塞工作线程直到所有的任务都执行完毕，分别是shutdown请求发出，达到终止超时时间，或者当前线程被中断。其中等待终止的最大超时时间是由timeout参数指定的，该参数的单位由第二个unit参数指定，时间单位使用TimeUnit枚举，比如TimeUnit.SECONDS表示秒。如果当前线程被中断，那么该方法会抛出java.lang.InterruptedException异常。当等待超过设定时间时，会监测ExecutorService是否已经关闭，若关闭则返回true，否则返回false。一般情况下会和shutdown方法组合使用。</li>
<li><strong>boolean isShutdown()</strong>返回Executor是否已经关闭。</li>
<li><strong>void shutdown()</strong>平滑的关闭ExecutorService，当此方法被调用时，ExecutorService停止接收新的任务并且等待已经提交的任务（包含提交正在执行和提交未执行）执行完成。当所有提交任务执行完毕，线程池即被关闭。</li>
<li><strong>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</strong>提交一个可返回结果的task。该方法的返回值是一个Future类型，Future\<v>接口提供了表示异步任务返回结果的方式。结果要以”future”命名是因为直到未来的某一刻结果才是有效的。它可以对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作。Callable\<v>接口和Runnable接口比较类似，同样提供了一个描述任务执行的方法，区别在于其call方法可以返回结果，也会抛出异常。</v></v></li>
<li><strong>Future&lt;?&gt; submit(Runnable task)</strong>提交一个Runnable任务并返回对应的Future。</li>
</ul>
<h3 id="Executor-factory-methods"><a href="#Executor-factory-methods" class="headerlink" title="Executor factory methods"></a>Executor factory methods</h3><p>终于讲到如何来创建一个Executor了。Executor framework提供了Executors工具类来创建Executor。它包含多种工厂方法来获取不同种类的Executor，每种Executor都有自己独特的线程执行策略。常用的三个例子如下：  </p>
<ul>
<li><strong>ExecutorService newCachedThreadPool()</strong>提供能够按需创建线程的线程池，但是可以重用之前创建的线程。60秒没有被使用过的线程会被终止并从池中删除。该线程池的使用场景是：包含大量短生命周期异步任务的应用。</li>
<li><strong>ExecutorService newSingleThreadExecutor()</strong>创建出的Executor仅仅包含一个工作线程，同时该线程会操作一个无界的任务队列 – 任务被添加到队列之中并被工作线程顺序的执行(在同一时刻只有且仅有一个任务处于活跃状态)。如果在Executor运行期间该唯一的工作线程异常终止，则会重新创建一个新的工作线程。</li>
<li><strong>ExecutorService newFixedThreadPool(int nThreads)</strong>创建一个重用固定数目线程的线程池，这些线程共享一个无界的任务队列。 该线程池的特点是最多只会有n个活跃线程处理任务。如果有任务到达但是所有的工作线程都处于活跃状态，那么会进入任务队列等待，直到有工作线程空闲。同SingleThreadExecutor，如果有线程异常终止，会新创建一个线程顶替。</li>
</ul>
<p>Executor framework还提供了如ScheduledExecutorService等多种类型的工具类, 但是开发过程中最常用到的就是ExecutorService, Future, Callable和Executors。</p>
<h3 id="Working-with-the-Executor-framework"><a href="#Working-with-the-Executor-framework" class="headerlink" title="Working with the Executor framework"></a>Working with the Executor framework</h3><p>你会发现Executor framework十分易于使用。在下面这段代码中，我们使用Executor和Executors对之前的Server例子进行了重写。使用线程池，提供了更好的可扩展性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.net.ServerSocket;</div><div class="line"><span class="keyword">import</span> java.net.Socket;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImproveServer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> Executor pool = Executors.newFixedThreadPool(<span class="number">5</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</div><div class="line">            Runnable r = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    doWork(socket);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            pool.execute(r);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Socket socket)</span> </span>&#123;</div><div class="line">        <span class="comment">// do some work with socket</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上段代码中使用newFixedThreadPool(int)创建了一个包含五个固定工作线程的线程池。同时也使用pool.execute(r)替换了new Thread(r).start()，来让线程池中的工作线程处理服务器收到的请求。<br>下面看一个稍微复杂一点的例子，下段代码中提供了一个能够读取并输出任意web页面内容的例子，如果5秒内未能获取到有效数据，则抛出异常。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.BufferedReader;</div><div class="line"><span class="keyword">import</span> java.io.InputStreamReader;</div><div class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</div><div class="line"><span class="keyword">import</span> java.net.URL;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWebPage</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</div><div class="line">            System.err.println(<span class="string">"usage: java ReadWebPage url"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</div><div class="line">        Callable&lt;List&lt;String&gt;&gt; callable;</div><div class="line">        callable = <span class="keyword">new</span> Callable&lt;List&lt;String&gt;&gt;() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                List&lt;String&gt; lines = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">                URL url = <span class="keyword">new</span> URL(args[<span class="number">0</span>]);</div><div class="line">                HttpURLConnection connection;</div><div class="line">                connection = (HttpURLConnection) url.openConnection();</div><div class="line">                InputStreamReader isr;</div><div class="line">                isr = <span class="keyword">new</span> InputStreamReader(connection.getInputStream());</div><div class="line">                BufferedReader br;</div><div class="line">                br = <span class="keyword">new</span> BufferedReader(isr);</div><div class="line">                String line;</div><div class="line">                <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">                    lines.add(line);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> lines;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        Future&lt;List&lt;String&gt;&gt; future = executor.submit(callable);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            List&lt;String&gt; lines = future.get(<span class="number">5</span>, TimeUnit.SECONDS);</div><div class="line">            <span class="keyword">for</span> (String line: lines)</div><div class="line">                System.out.println(line);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | TimeoutException e) &#123;</div><div class="line">            System.err.println(<span class="string">"URL not responding"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            System.err.println(<span class="string">"Callable through exception: "</span> + e.getMessage());</div><div class="line">        &#125;</div><div class="line">        executor.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，无论是否有异常抛出，Executor必须在程序退出之前关闭。否则应用将会因为Executor线程池中的非守护进程仍在运行而无法退出。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://roronoa.space/2017/06/21/每天十道JAVA面试题-DAY1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="roronoa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="roronoa space">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/21/每天十道JAVA面试题-DAY1/" itemprop="url">
                  每天十道Java面试题-DAY1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-21T10:00:00+08:00">
                2017-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="QUESTION-1-请简单介绍一下Java这门语言"><a href="#QUESTION-1-请简单介绍一下Java这门语言" class="headerlink" title="QUESTION 1: 请简单介绍一下Java这门语言"></a>QUESTION 1: 请简单介绍一下Java这门语言</h3><p>Java编程环境出现于20世纪90年代末，由Java语言和运行时构成。运行时也叫Java虚拟机(Java Virtual Machine，JVM)。</p>
<h4 id="1-Java语言是什么？"><a href="#1-Java语言是什么？" class="headerlink" title="1. Java语言是什么？"></a>1. Java语言是什么？</h4><p>Java语言即Java程序的源码，是人类可读的编程语言，基于类，面向对象，并且比较易读易写。其受Java语言规范(Java Language Specification，JLS)的约束。</p>
<h4 id="2-JVM是什么？"><a href="#2-JVM是什么？" class="headerlink" title="2. JVM是什么？"></a>2. JVM是什么？</h4><p>JVM是一个程序，提供了运行Java程序所需的运行时环境。如果某个硬件和操作系统平台没有相应的JVM，就不能运行Java程序。<br>我们熟知的命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java &lt;arguments&gt; &lt;program name&gt;</div></pre></td></tr></table></figure>
<p>实际上就是在操作系统的一个进程中启动JVM，提供Java运行时环境，然后在刚启动的虚拟机中运行指定的程序。</p>
<h4 id="3-JVM有哪些特点？"><a href="#3-JVM有哪些特点？" class="headerlink" title="3. JVM有哪些特点？"></a>3. JVM有哪些特点？</h4><ol>
<li>提供给JVM运行的程序并不是Java语言源码，源码必须转换(或编译)成为一种称为<strong>Java字节码</strong>的格式，并且必须是类文件格式，其扩展名为.class。从这个角度看，JVM实际上就是字节码格式程序的解释器，一次只执行字节码中的一个指令。</li>
<li>较之C和C++的方式，JVM提供了一个相对<strong>安全的执行环境</strong>，它代替开发者<strong>管理内存</strong>，并且提供了一个<strong>跨平台</strong>的执行环境。</li>
<li>另外一个很少被提及的特点是，JVM可以<strong>使用运行时信息进行自我管理</strong>(可能是真正意义上第一个具有这种特性的主流开发平台)。JVM会收集程序运行时的信息，并对如何执行代码做出更好的决定。(比如HotSpot JVM，就能够识别出程序中的“热点方法”，然后跳过JVM解释器，直接把这一部分编译成机器码，这是通过一种叫JIT编译(Just-In-Time compilation)的技术实现的)。</li>
</ol>
<h3 id="QUESTION-2-请简单介绍一下Java程序的生命周期？"><a href="#QUESTION-2-请简单介绍一下Java程序的生命周期？" class="headerlink" title="QUESTION 2: 请简单介绍一下Java程序的生命周期？"></a>QUESTION 2: 请简单介绍一下Java程序的生命周期？</h3><p>下面的这张图摘选自《Java技术手册(第六版)》，简要的说明看Java程序的生命周期。<br><img src="/images/java_program_life_cycle.png" alt="Java Program Life Cycle"><br>整个流程从Java源码开始，经过Javac程序处理后得到类文件(.class)，类文件中保存的是编译之后的Java字节码，同时它也是Java平台能够处理的最小功能单位，是把新代码传递给运行中程序的唯一方式。<br>那么这里又引出来一些新的问题：</p>
<h4 id="1-字节码是什么？为什么叫字节码？它真的和设备无关么？"><a href="#1-字节码是什么？为什么叫字节码？它真的和设备无关么？" class="headerlink" title="1.字节码是什么？为什么叫字节码？它真的和设备无关么？"></a>1.字节码是什么？为什么叫字节码？它真的和设备无关么？</h4><p>字节码是位于Java源码和机器码之间的一种”中间表现形式”，其目的是提供一种能够让JVM解释器高效执行的格式。<br>叫字节码的原因是因为指令码(操作码)只占有<strong>一个字节</strong>(有些操作可以带参数)，所以共计只有256个可用的指令。然而实际上大概只会使用200个左右。<br>字节码不管在哪种设备中生成，其格式都是一样的，其中也包括设备使用的字节顺序(big-endian)。</p>
<h4 id="2-Javac是编译器么？"><a href="#2-Javac是编译器么？" class="headerlink" title="2.Javac是编译器么？"></a>2.Javac是编译器么？</h4><p>从标准的编译定义来看，Javac非常像编译器的“前半部分”，生成的中间表现形式可以进一步处理生成机器码。不过因为类文件的生成是构建过程中单独的异步，通常开发者也可以把运行Javac的操作称为编译。</p>
<h4 id="3-类文件是怎么加载进虚拟机的？"><a href="#3-类文件是怎么加载进虚拟机的？" class="headerlink" title="3.类文件是怎么加载进虚拟机的？"></a>3.类文件是怎么加载进虚拟机的？</h4><p>这个之后详细介绍。</p>
<h3 id="QUESTION-3-请简单介绍一下类和对象的定义？"><a href="#QUESTION-3-请简单介绍一下类和对象的定义？" class="headerlink" title="QUESTION 3: 请简单介绍一下类和对象的定义？"></a>QUESTION 3: 请简单介绍一下类和对象的定义？</h3><p><strong>类</strong>是一段代码的名称，其中包含很多保存数据值的字段和操作这些值的方法。类是Java支持的五种引用类型之一，而且是最重要的一种。<br>类是一种数据类型，而类表示的值就是<strong>对象</strong>。对象一般通过实例化类创建，方法是使用new关键字并调用构造方法，例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point p = <span class="keyword">new</span> Point(<span class="number">1.0</span>,<span class="number">2.0</span>);</div></pre></td></tr></table></figure>
<h3 id="QUESTION-4-请比较一下Java中引用类型和基本类型的不同？"><a href="#QUESTION-4-请比较一下Java中引用类型和基本类型的不同？" class="headerlink" title="QUESTION 4: 请比较一下Java中引用类型和基本类型的不同？"></a>QUESTION 4: 请比较一下Java中引用类型和基本类型的不同？</h3><p>在Java中，引用类型和对象与基本类型和基本值有着本质的区别。  </p>
<ol>
<li>八种基本类型由Java语言定义，程序员不能定义新的基本类型，而引用类型由用户定义，因此可以有无限多个。</li>
<li>基本类型表示单个值，而引用类型是聚合类型，可以保存零个或多个基本值或对象。</li>
<li>基本类型需要一到八个字节的内存空间。把基本值存储到变量中，或者传入方法时，实际上计算机会复制表示这个值的字节（也可以叫做<strong>传值</strong>）。而对象需要更多的内存，创建对象时会在<strong>堆(heap)</strong>动态分配内存，存储这个对象。如果不再需要使用这个对象了，存储它的内存会被自动<strong>垃圾回收</strong>。当把对象赋值给变量或是传入方法时，不会复制表示这个对象的内存，而是把这个内存的引用存储在变量中或传入方法(也可以叫<strong>传址</strong>)。</li>
</ol>
<h3 id="QUESTION-5-请简单介绍一下Java中字段的修饰符有哪些？"><a href="#QUESTION-5-请简单介绍一下Java中字段的修饰符有哪些？" class="headerlink" title="QUESTION 5: 请简单介绍一下Java中字段的修饰符有哪些？"></a>QUESTION 5: 请简单介绍一下Java中字段的修饰符有哪些？</h3><ol>
<li><strong>public,protected,private。</strong>这些访问控制修饰符指明字段能否在定义它的类之外使用，以及能在何处使用。</li>
<li><strong>static。</strong>这个修饰符指明字段关联在定义在它的类自身上，而不是类的实例身上。（注意，公开的静态字段要尽量声明为final，因为多个线程都能够修改字段的值，会导致极难调试的行为）。</li>
<li><strong>final。</strong>这个修饰符指明字段一旦初始化，其值就不能改变。如果字段同时使用static和final修饰，那么这个字段就是编译时常量，Javac会将其内联化。</li>
<li><strong>transient。</strong>这个修饰符指明字段不是对象持久状态的一部分，无需跟对象的其他内容一起序列化。</li>
<li><strong>volatile。</strong>这个修饰符指明字段可以被两个或多个线程同时使用，其深层含义是指字段的值必须始终从主存储器中读取和释放，不能够被线程缓存(在寄存器或者CPU缓存中)。</li>
</ol>
<h3 id="QUESTION-6-Java中的方法重载和方法覆盖区别是什么？"><a href="#QUESTION-6-Java中的方法重载和方法覆盖区别是什么？" class="headerlink" title="QUESTION 6: Java中的方法重载和方法覆盖区别是什么？"></a>QUESTION 6: Java中的方法重载和方法覆盖区别是什么？</h3><ol>
<li><strong>方法重载</strong>指的是在同一个中定义多个名称相同但是参数列表不同的方法。</li>
<li><strong>方法覆盖</strong>指的是如果类中的某个实例方法和超类中的某个方法有相同的名称、返回值类型和参数，那么这个方法会<strong>覆盖(override)</strong>超类中对应的方法。在这个类的对象上调用这个方法时，调用的是新定义的方法，而不是超类中定义的旧方法。下面是一个小例子，注意，下面的例子同时也展示了方法覆盖和字段遮盖之间的区别。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">'A'</span>; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> i = <span class="number">2</span>;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> -i; &#125;</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">'B'</span>; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> OverrideTest &#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		B b = <span class="keyword">new</span> B();</div><div class="line">		System.out.println(b.i); <span class="comment">//引用B.i, 打印2</span></div><div class="line">		System.out.println(b.f()); <span class="comment">//引用B.f(), 打印-2</span></div><div class="line">		System.out.println(b.g()); <span class="comment">//引用B.g(), 打印B</span></div><div class="line">		System.out.println(B.g()); <span class="comment">//更好的写法</span></div><div class="line">		A a = (A)b; <span class="comment">// 把b矫正成类A的实例</span></div><div class="line">		System.out.println(b.i); <span class="comment">//引用A.i, 打印1</span></div><div class="line">		System.out.println(b.f()); <span class="comment">//引用B.f(), 打印-2</span></div><div class="line">		System.out.println(b.g()); <span class="comment">//引用A.g(), 打印A</span></div><div class="line">		System.out.println(B.g()); <span class="comment">//更好的写法</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现方法覆盖这个看起来很神奇的功能背后的机制在于，Javac生成的字节码会在运行时使用“虚拟方法查找(virtual method lookup)”。解释器运行代码时，会查找变量引用对象的真正运行时类型，然后找到适用于这个类型的对应方法。</p>
<h3 id="QUESTION-7-封装的含义是什么？其意义在于？"><a href="#QUESTION-7-封装的含义是什么？其意义在于？" class="headerlink" title="QUESTION 7: 封装的含义是什么？其意义在于？"></a>QUESTION 7: 封装的含义是什么？其意义在于？</h3><p>简单来说，<strong>封装(encapsulation)</strong>就是把数据隐藏在类中，只能通过方法获取。<br>其意义在于以下两点：  </p>
<ol>
<li>最重要的原因在于，<strong>隐藏类的内部实现细节</strong>，避免让程序员依赖这些细节，从而可以放心的对内部实现细节进行修改而无需担心破坏使用这个类的现有代码。</li>
<li>另一个原因在于<strong>保护类</strong>，防止因直接操作字段导致类的状态出现前后不一致。</li>
</ol>
<h3 id="QUESTION-8-请介绍一下Java中的嵌套类型？"><a href="#QUESTION-8-请介绍一下Java中的嵌套类型？" class="headerlink" title="QUESTION 8: 请介绍一下Java中的嵌套类型？"></a>QUESTION 8: 请介绍一下Java中的嵌套类型？</h3><h4 id="1-常见嵌套类型"><a href="#1-常见嵌套类型" class="headerlink" title="1.常见嵌套类型"></a>1.常见嵌套类型</h4><p><strong>嵌套类(又常被称为内部类)</strong>通常是指在其他类型中定义的类，其主要有两个目的：</p>
<ol>
<li><strong>如果某个类需要特别深入地访问另一个类的内部实现，就可以嵌套定义这个类。</strong>作为成员类型的嵌套类型，其访问方式与访问成员变量和方法的方式一样，而且能打破封装的规则。</li>
<li><strong>某个类型可能只在特定的情况下需要使用，而且只在非常小的代码区域使用。</strong>这个类型应该密封在一个小范围内(其他模块无法接触到的地方)，因为它实际上是实现细节的一部分。</li>
</ol>
<p>类能够通过四种不同的方式嵌套在其他类中。</p>
<ol>
<li><strong>静态成员类型。</strong>它和普通的顶层类型很像，只是为了方便，把它嵌套在另一个类型的命名空间中。静态成员类型具有如下几点基本特性：<ul>
<li>类似于类的其他静态成员: 静态字段和方法。</li>
<li>静态成员类型和所在类的任何实例都不关联(即没有this对象)，这个很好理解，因为静态成员类型也是绑定在类上而不是实例上的。</li>
<li>静态成员类型只能访问所在类的静态成员，包括私有成员，反过来也成立。</li>
<li>不管是否使用static关键字，嵌套的接口、枚举和注解都隐式声明为静态类型。</li>
</ul>
</li>
<li><strong>非静态成员类。</strong><ul>
<li>如果把静态成员类型比作类字段或者类方法，那么非静态成员类可以比作<strong>实例字段或者实例方法</strong>。</li>
<li>一个非静态成员类的实例始终关联一个外层类型的实例。</li>
<li>非静态成员类的代码能访问外层类型的所有字段和方法(静态+非静态)。</li>
<li>非静态成员类不能包含任何静态字段、方法或类型，这是因为静态成员是顶层结构，不和任何特定的对象相关联，而非静态成员类和外层类的实例相关联。在成员类中定义顶层的静态成员会让人困惑，因此禁止这么做。</li>
</ul>
</li>
<li><strong>局部类。</strong>必须在一个Java代码块中声明，不是类的成员。和局部变量一样，局部类只在定义它的块中有效。<ul>
<li>局部类能使用同一个作用域的局部变量，方法参数和异常参数，但是这些变量或参数必须声明为final。这是因为，局部类用到的每一个局部变量都有一个私有内部副本(由Javac自动生成)。并且，局部类实例的生命周期可能比定义它的方法执行时间长的多，所以只有把局部变量声明为final才能保证局部变量和私有副本始终保持一致。例子如下：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="keyword">protected</span> <span class="keyword">char</span> a = <span class="string">'a'</span>; &#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123; <span class="keyword">protected</span> <span class="keyword">char</span> b = <span class="string">'b'</span>; &#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">char</span> c = <span class="string">'c'</span>; <span class="comment">//私有字段，对局部类可见</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> d = <span class="string">'d'</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createLocalObject</span><span class="params">(<span class="keyword">final</span> <span class="keyword">char</span> e)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> <span class="keyword">char</span> f = <span class="string">'f'</span>;</div><div class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Local</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</div><div class="line">			<span class="keyword">char</span> g = <span class="string">'g'</span>;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printVars</span><span class="params">()</span> </span>&#123;</div><div class="line">				System.out.println(g); <span class="comment">// this.g</span></div><div class="line">				System.out.println(f); <span class="comment">// f是声明为final的局部变量</span></div><div class="line">				System.out.println(e); <span class="comment">// e是声明为final的局部变量</span></div><div class="line">				System.out.println(d); <span class="comment">// C.this.d</span></div><div class="line">				System.out.println(c); <span class="comment">// C.this.c</span></div><div class="line">				System.out.println(b); <span class="comment">// b是这个类继承的字段</span></div><div class="line">				System.out.println(a); <span class="comment">// a是外层类继承的字段</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		Local l = <span class="keyword">new</span> Local();</div><div class="line">		l.printVars();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong>匿名类。</strong>其实就是没有名称的局部类。<ul>
<li>因为没有名称，所以匿名类无法实现构造方法。</li>
<li>在Java 8中，大多数情况下匿名类已经被lambda表达式替换。</li>
</ul>
</li>
</ol>
<h4 id="2-嵌套类型的运作方式"><a href="#2-嵌套类型的运作方式" class="headerlink" title="2.嵌套类型的运作方式"></a>2.嵌套类型的运作方式</h4><p>首先需要确定的是，<strong>引入嵌套类型后，Java虚拟机和Java类文件的格式都没有变化。对Java解释器而言，并没有所谓的嵌套类型，所有类都是普通的顶层类。</strong><br>为了实现嵌套类型，javac把每个嵌套类型编译为单独的类文件，得到的其实是顶层类。编译得到的类文件使用特殊的命名约定，如下所示：</p>
<ul>
<li>(静态或非静态)成员类型。根据EnclosingType$Member.class格式命名成员类型的类文件。</li>
<li>匿名类。因为匿名类没有名称，所以由具体的实现细节决定。Oracle/OpenJDK中的javac使用数字表示匿名类的名称(EnclosingType$1.class)。</li>
<li>局部类。综合使用前两种方式命名(EnclosingType$1Member.class)。</li>
</ul>
<p>因为嵌套类型编译成普通的顶层类，所以不能直接访问外层类型中具有特定权限的成员。javac通过在非静态成员类或局部类当中保存外层实例引用的方式，提供了嵌套类所需的合成访问能力。</p>
<h3 id="QUESTION-9-在Java中，应该使用接口还是抽象类？"><a href="#QUESTION-9-在Java中，应该使用接口还是抽象类？" class="headerlink" title="QUESTION 9: 在Java中，应该使用接口还是抽象类？"></a>QUESTION 9: 在Java中，应该使用接口还是抽象类？</h3><p>Java 8的出现从根本上改变了Java的面向对象编程模型。<br>在Java 8之前，接口纯粹是API规范，不包含实现。如果接口有大量实现，往往会导致代码重复。而Java 8中引入了默认方法，显著改变了这一情况。<br>一般来说，需要制定API规范时，推荐选择接口。接口中强制方法不是默认方法，因为它们是API的一部分，实现方要提供有效的实现。只有当方法是真正可选的，或者只有一种可能的实现时，才应该使用默认方法。</p>
<h3 id="QUESTION-10-请介绍并写一下单例模式"><a href="#QUESTION-10-请介绍并写一下单例模式" class="headerlink" title="QUESTION 10: 请介绍并写一下单例模式"></a>QUESTION 10: 请介绍并写一下单例模式</h3><p>单例模式(Singleton Pattern)是用来解决只需要为类创建一个实例这种设计问题。它是最简单的模式之一，一般用于管理配置，现代代码中也经常使用自动为程序员提供单例的框架(一般是<strong>依赖注入</strong>)。<br>单例虽然是很实用，但是由于存在有难测试，需考虑多线程等一些问题，要避免过度使用。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> initialized = <span class="keyword">false</span>;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 做初始化操作</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (initialized) <span class="keyword">return</span> instance;</div><div class="line">		instance.init();</div><div class="line">		initialized = <span class="keyword">true</span>;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="roronoa" />
          <p class="site-author-name" itemprop="name">roronoa</p>
           
              <p class="site-description motion-element" itemprop="description">you cannot win with a losing hand</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">roronoa</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
