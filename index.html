<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="you cannot win with a losing hand">
<meta property="og:type" content="website">
<meta property="og:title" content="roronoa space">
<meta property="og:url" content="http://roronoa.space/index.html">
<meta property="og:site_name" content="roronoa space">
<meta property="og:description" content="you cannot win with a losing hand">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="roronoa space">
<meta name="twitter:description" content="you cannot win with a losing hand">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://roronoa.space/"/>





  <title> roronoa space </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">roronoa space</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">three thousand worlds</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://roronoa.space/2017/06/23/Java_concurrency_part_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="roronoa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="roronoa space">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/23/Java_concurrency_part_1/" itemprop="url">
                  Java并发编程-Part 1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-23T20:02:00+08:00">
                2017-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着多线程应用开发与日俱增的复杂性，许多开发者发现Java的底层并发机制已经不能够满足他们的需求。在这种情况下，是时候对java.util.concurrent包提供的功能进行全面的探索了。这其中包括Executor框架，Synchronizer类型，以及Java并发集合等等。<br>Java平台提供了底层的并发编程功能，能够为开发者提供多线程同步执行的能力。标准的Java多线程是存在一些缺陷的，比如：  </p>
<ol>
<li>Java底层的并发原语(<font color="#800000">synchronized</font>,<font color="#800000">volatile</font>, <font color="#800000">wait()</font>, <font color="#800000">notify()</font>, 和<font color="#800000">notifyAll()</font>)很难被正确的使用。因为错误使用这些原语导致出现的一些如线程死锁，线程饥饿，竞态等问题，也很难复现和排查。</li>
<li>多线程同步访问公共资源很容易成为应用性能的瓶颈点，影响应用的可扩展性，而这往往是许多现代应用的刚需。</li>
<li>Java提供的基础多线程编程功能太过于底层，开发者往往需要使用更高层次的抽象比如信号量和线程池，然而这些Java底层并没有提供。由此而引发的就是开发者需要自行构建上述抽象，而这往往十分浪费时间并且容易出现问题。</li>
</ol>
<p>正因为以上这些问题，<a href="https://www.jcp.org/en/jsr/detail?id=166" target="_blank" rel="external">JSR 166: Concurrency Utilities framework</a>在2002年被首次提出了，其设计的目的是用来为开发者提供高层次的并发编程能力。2年后也就是2004年，该框架在Java 5中被正式实现，并且在后续的版本中进行了逐步的完善。<br>本系列文章的目的是向开发者介绍Java Concurrency Utilities中的内容。在第一部分，会首先对该并发框架进行一个概览，并对Executor框架，synchronizer工具包，以及Java并发集合(Concurrent Collections)进行介绍。</p>
<h2 id="走进Java-Concurrency-Utilities"><a href="#走进Java-Concurrency-Utilities" class="headerlink" title="走进Java Concurrency Utilities"></a>走进Java Concurrency Utilities</h2><p><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/concurrency/" target="_blank" rel="external">Java Concurrency Utilities framework</a>是由一些专门设计用来构造多线程并发程序的<a href="http://www.javaworld.com/article/2074906/core-java/thanks-type-and-gentle-class.html" target="_blank" rel="external">类</a>所组成的。框架中所有的类都是线程安全的，并且都经过完善的测试，能够保障高性能。<br>Java Concurrency Utilities中的类型被组织成几个小的框架，从包命名上可以区分为Executor framework, synchronizer, concurrent collections, locks, atomic variables和Fork/Join。它们进一步又被细分为一个主package和一系列子package：</p>
<ul>
<li><strong>java.util.concurrent</strong>包含一些在并发编程中常用的工具类。例子包括semaphores, barriers, thread pools和concurrent hashmaps。  <ul>
<li><strong>java.util.concurrent.atomic</strong>包含一些底层的并发工具类，能够支持单变量的无锁化线程安全机制。</li>
<li><strong>java.util.concurrent.locks</strong>提供了一些不同于底层synchronization和monitors的加锁和临界区资源等待的工具类。</li>
</ul>
</li>
</ul>
<p>Java Concurrency Utilities框架同时也暴露了底层的compare-and-swap (CAS)硬件指令，其变体能够被大多数现代处理器所支持。CAS同时比基于Java monitor的同步机制更加轻量级，能够用来实现一些可以高度可扩展的并发工具类。基于CAS的<font color="#800000">java.util.concurrent.locks.ReentrantLock</font>类(可重入锁)，能够获得比<font color="#800000">synchronized</font>更好的性能。ReentrantLock同时能够提供更为可控的加锁机制。(在第二部分我会更为详细的讲解CAS是如何在<font color="#800000">java.util.concurrent</font>当中工作的)。</p>
<blockquote>
<p><strong>System.nanoTime()</strong></p>
<p>Java Concurrency Utilities框架包含返回long类型时间戳的<font color="#800000">nanoTime()</font>方法。这个方法能够保证纳秒级别的精度，可以用来做时间测定。</p>
</blockquote>
<p>在下面的几个部分中，我将依次介绍Java Concurrency Utilities中的三个实用特性。首先会解释为什么这些特性对现代并发编程如此重要，之后会演示这些工具类是如何工作的，是如何提升Java并发程序的运行速度，可靠性，工作效率和可扩展性的。  </p>
<h3 id="The-Executor-framework"><a href="#The-Executor-framework" class="headerlink" title="The Executor framework"></a>The Executor framework</h3><p>In threading, a task is a unit of work. One problem with low-level threading in Java is that task submission is tightly coupled with a task-execution policy, as demonstrated by Listing 1.<br>在多线程编程中，我们将task称为一个工作单元。Java底层并发机制的问题在于task的提交与task的执行是强相关的，就如下面这段代码所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line"></div><div class="line">public class Server &#123;</div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        ServerSocket serverSocket = new ServerSocket(9000);</div><div class="line">        while (true) &#123;</div><div class="line">            final Socket socket = serverSocket.accept();</div><div class="line">            Runnable r = new Runnable() &#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    doWork(socket);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            new Thread(r).start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void doWork(Socket socket) &#123;</div><div class="line">        // do some work with socket</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码描述了一个简单的服务器应用是如何运行的。服务器线程在一个死循环当中重复的在指定端口上调用<font color="#800000">socket.accept()</font>方法(注意该方法是阻塞式的)来接收客户端发送过来的请求，在接收到请求之后，服务器会启动一个线程来对该请求做进一步的处理。<br>因为示例代码中的应用为每一个请求都会新建一个线程来处理，当有大量请求到达服务器时，其无法对线程数目进行控制。由于每个创建出来的线程都会占用一定的内存，过多的线程会耗尽系统的可用内存，使应用异常终止。<br>上述问题可以通过改变task的执行策略来解决。相比于每次请求都新建一个线程来处理，使用线程池往往被认为是更好的方式。对于接受到的请求，线程池能够控制固定数目的线程来处理，避免了线程无限增长的情况。之后我们会使用<font color="#800000">java.util.concurrent</font>中提供的工具类来重写上面这段代码。  </p>
<p><font color="#800000">java.util.concurrent</font>包中包含了<a href="http://www.javaworld.com/article/2071822/java-concurrency/book-excerpt--executing-tasks-in-threads.html" target="_blank" rel="external">Executor framework</a>，一个专门用来解耦任务提交和任务执行策略的框架。利用该包提供的功能，我们可以十分方便的调整程序的任务执行策略，并且只需要对代码进行一些细微的改动。</p>
<h3 id="Inside-the-Executor-framework"><a href="#Inside-the-Executor-framework" class="headerlink" title="Inside the Executor framework"></a>Inside the Executor framework</h3><p>Executor framework基于<font color="#800000">Executor</font>接口，实现该接口的类被认为有能力执行<font color="#800000">java.lang.Runnable</font>任务。其中仅仅提供了一个需要实现的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Executes the given command at some time in the future.  The command</div><div class="line">     * may execute in a new thread, in a pooled thread, or in the calling</div><div class="line">     * thread, at the discretion of the &#123;@code Executor&#125; implementation.</div><div class="line">     *</div><div class="line">     * @param command the runnable task</div><div class="line">     * @throws RejectedExecutionException if this task cannot be</div><div class="line">     * accepted for execution</div><div class="line">     * @throws NullPointerException if command is null</div><div class="line">     */</div><div class="line">    void execute(Runnable command);</div></pre></td></tr></table></figure>
<p>提交一个Runnable任务的方式就是将其作为参数传入execute方法。如果executor由于一些原因不能执行任务(比如已经shut down了)，那么该方法会抛出一个<font color="#800000">RejectedExecutionException</font>异常。<br>Executor接口定义的关键点在于任务提交和任务执行策略的解耦。解耦之后Runnable任务能够根据开发者的需求实现多种执行策略，比如新建一个线程，使用线程池，或者使用Callable(后续会介绍)等等。<br>注意，仅仅定义一个Executor接口是非常有局限性的。你不能终止一个executor的运行，不能判断一个异步任务是否执行结束，同时你也不能取消一个正在运行的任务。基于以上几点缺陷，Executor framework另外提供了一个<font color="#800000">ExecutorService</font>接口，它是继承自Executor接口的。<br>在ExecutorService提供的方法中，有下面五个值得注意的：</p>
<ul>
<li><strong>boolean awaitTermination(long timeout, TimeUnit unit)</strong>三种情况会使Executor阻塞工作线程直到所有的任务都执行完毕，分别是shutdown请求发出，达到终止超时时间，或者当前线程被中断。其中等待终止的最大超时时间是由timeout参数指定的，该参数的单位由第二个unit参数指定，时间单位使用TimeUnit枚举，比如TimeUnit.SECONDS表示秒。如果当前线程被中断，那么该方法会抛出java.lang.InterruptedException异常。当等待超过设定时间时，会监测ExecutorService是否已经关闭，若关闭则返回true，否则返回false。一般情况下会和shutdown方法组合使用。</li>
<li><strong>boolean isShutdown()</strong>返回Executor是否已经关闭。</li>
<li><strong>void shutdown()</strong>平滑的关闭ExecutorService，当此方法被调用时，ExecutorService停止接收新的任务并且等待已经提交的任务（包含提交正在执行和提交未执行）执行完成。当所有提交任务执行完毕，线程池即被关闭。</li>
<li><strong>\<t> Future\<t> submit(Callable\<t> task)</t></t></t></strong>提交一个可返回结果的task。该方法的返回值是一个Future类型，Future\<v>接口提供了表示异步任务返回结果的方式。结果要以”future”命名是因为直到未来的某一刻结果才是有效的。它可以对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作。Callable\<v>接口和Runnable接口比较类似，同样提供了一个描述任务执行的方法，区别在于其call方法可以返回结果，也会抛出异常。</v></v></li>
<li><strong>Future\&lt;?&gt; submit(Runnable task)</strong>提交一个Runnable任务并返回对应的Future。</li>
</ul>
<h3 id="Executor-factory-methods"><a href="#Executor-factory-methods" class="headerlink" title="Executor factory methods"></a>Executor factory methods</h3><p>终于讲到如何来创建一个Executor了。Executor framework提供了Executors工具类来创建Executor。它包含多种工厂方法来获取不同种类的Executor，每种Executor都有自己独特的线程执行策略。常用的三个例子如下：  </p>
<ul>
<li><strong>ExecutorService newCachedThreadPool()</strong>提供能够按需创建线程的线程池，但是可以重用之前创建的线程。60秒没有被使用过的线程会被终止并从池中删除。该线程池的使用场景是：包含大量短生命周期异步任务的应用。</li>
<li><strong>ExecutorService newSingleThreadExecutor()</strong>创建出的Executor仅仅包含一个工作线程，同时该线程会操作一个无界的任务队列 – 任务被添加到队列之中并被工作线程顺序的执行(在同一时刻只有且仅有一个任务处于活跃状态)。如果在Executor运行期间该唯一的工作线程异常终止，则会重新创建一个新的工作线程。</li>
<li><strong>ExecutorService newFixedThreadPool(int nThreads)</strong>创建一个重用固定数目线程的线程池，这些线程共享一个无界的任务队列。 该线程池的特点是最多只会有n个活跃线程处理任务。如果有任务到达但是所有的工作线程都处于活跃状态，那么会进入任务队列等待，直到有工作线程空闲。同SingleThreadExecutor，如果有线程异常终止，会新创建一个线程顶替。</li>
</ul>
<p>Executor framework还提供了如ScheduledExecutorService等多种类型的工具类, 但是开发过程中最常用到的就是ExecutorService, Future, Callable和Executors。</p>
<h3 id="Working-with-the-Executor-framework"><a href="#Working-with-the-Executor-framework" class="headerlink" title="Working with the Executor framework"></a>Working with the Executor framework</h3><p>你会发现Executor framework十分易于使用。在下面这段代码中，我们使用Executor和Executors对之前的Server例子进行了重写。使用线程池，提供了更好的可扩展性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import java.io.IOException;</div><div class="line">import java.net.ServerSocket;</div><div class="line">import java.net.Socket;</div><div class="line">import java.util.concurrent.Executor;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line"></div><div class="line">public class ImproveServer &#123;</div><div class="line"></div><div class="line">    static Executor pool = Executors.newFixedThreadPool(5);</div><div class="line"></div><div class="line">    public static void main(String[] args) throws IOException &#123;</div><div class="line">        ServerSocket serverSocket = new ServerSocket(9000);</div><div class="line">        while (true) &#123;</div><div class="line">            final Socket socket = serverSocket.accept();</div><div class="line">            Runnable r = new Runnable() &#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    doWork(socket);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            pool.execute(r);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static void doWork(Socket socket) &#123;</div><div class="line">        // do some work with socket</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上段代码中使用newFixedThreadPool(int)创建了一个包含五个固定工作线程的线程池。同时也使用pool.execute(r)替换了new Thread(r).start()，来让线程池中的工作线程处理服务器收到的请求。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://roronoa.space/2017/06/21/每天十道JAVA面试题-DAY1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="roronoa">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="roronoa space">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/21/每天十道JAVA面试题-DAY1/" itemprop="url">
                  每天十道Java面试题-DAY1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-21T10:00:00+08:00">
                2017-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="QUESTION-1-请简单介绍一下Java这门语言"><a href="#QUESTION-1-请简单介绍一下Java这门语言" class="headerlink" title="QUESTION 1: 请简单介绍一下Java这门语言"></a>QUESTION 1: 请简单介绍一下Java这门语言</h3><p>Java编程环境出现于20世纪90年代末，由Java语言和运行时构成。运行时也叫Java虚拟机(Java Virtual Machine，JVM)。</p>
<h4 id="1-Java语言是什么？"><a href="#1-Java语言是什么？" class="headerlink" title="1. Java语言是什么？"></a>1. Java语言是什么？</h4><p>Java语言即Java程序的源码，是人类可读的编程语言，基于类，面向对象，并且比较易读易写。其受Java语言规范(Java Language Specification，JLS)的约束。</p>
<h4 id="2-JVM是什么？"><a href="#2-JVM是什么？" class="headerlink" title="2. JVM是什么？"></a>2. JVM是什么？</h4><p>JVM是一个程序，提供了运行Java程序所需的运行时环境。如果某个硬件和操作系统平台没有相应的JVM，就不能运行Java程序。<br>我们熟知的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java &lt;arguments&gt; &lt;program name&gt;</div></pre></td></tr></table></figure>
<p>实际上就是在操作系统的一个进程中启动JVM，提供Java运行时环境，然后在刚启动的虚拟机中运行指定的程序。</p>
<h4 id="3-JVM有哪些特点？"><a href="#3-JVM有哪些特点？" class="headerlink" title="3. JVM有哪些特点？"></a>3. JVM有哪些特点？</h4><ol>
<li>提供给JVM运行的程序并不是Java语言源码，源码必须转换(或编译)成为一种称为<strong>Java字节码</strong>的格式，并且必须是类文件格式，其扩展名为.class。从这个角度看，JVM实际上就是字节码格式程序的解释器，一次只执行字节码中的一个指令。</li>
<li>较之C和C++的方式，JVM提供了一个相对<strong>安全的执行环境</strong>，它代替开发者<strong>管理内存</strong>，并且提供了一个<strong>跨平台</strong>的执行环境。</li>
<li>另外一个很少被提及的特点是，JVM可以<strong>使用运行时信息进行自我管理</strong>(可能是真正意义上第一个具有这种特性的主流开发平台)。JVM会收集程序运行时的信息，并对如何执行代码做出更好的决定。(比如HotSpot JVM，就能够识别出程序中的“热点方法”，然后跳过JVM解释器，直接把这一部分编译成机器码，这是通过一种叫JIT编译(Just-In-Time compilation)的技术实现的)。</li>
</ol>
<h3 id="QUESTION-2-请简单介绍一下Java程序的生命周期？"><a href="#QUESTION-2-请简单介绍一下Java程序的生命周期？" class="headerlink" title="QUESTION 2: 请简单介绍一下Java程序的生命周期？"></a>QUESTION 2: 请简单介绍一下Java程序的生命周期？</h3><p>下面的这张图摘选自《Java技术手册(第六版)》，简要的说明看Java程序的生命周期。<br><img src="/images/java_program_life_cycle.png" alt="Java Program Life Cycle"><br>整个流程从Java源码开始，经过Javac程序处理后得到类文件(.class)，类文件中保存的是编译之后的Java字节码，同时它也是Java平台能够处理的最小功能单位，是把新代码传递给运行中程序的唯一方式。<br>那么这里又引出来一些新的问题：</p>
<h4 id="1-字节码是什么？为什么叫字节码？它真的和设备无关么？"><a href="#1-字节码是什么？为什么叫字节码？它真的和设备无关么？" class="headerlink" title="1.字节码是什么？为什么叫字节码？它真的和设备无关么？"></a>1.字节码是什么？为什么叫字节码？它真的和设备无关么？</h4><p>字节码是位于Java源码和机器码之间的一种”中间表现形式”，其目的是提供一种能够让JVM解释器高效执行的格式。<br>叫字节码的原因是因为指令码(操作码)只占有<strong>一个字节</strong>(有些操作可以带参数)，所以共计只有256个可用的指令。然而实际上大概只会使用200个左右。<br>字节码不管在哪种设备中生成，其格式都是一样的，其中也包括设备使用的字节顺序(big-endian)。</p>
<h4 id="2-Javac是编译器么？"><a href="#2-Javac是编译器么？" class="headerlink" title="2.Javac是编译器么？"></a>2.Javac是编译器么？</h4><p>从标准的编译定义来看，Javac非常像编译器的“前半部分”，生成的中间表现形式可以进一步处理生成机器码。不过因为类文件的生成是构建过程中单独的异步，通常开发者也可以把运行Javac的操作称为编译。</p>
<h4 id="3-类文件是怎么加载进虚拟机的？"><a href="#3-类文件是怎么加载进虚拟机的？" class="headerlink" title="3.类文件是怎么加载进虚拟机的？"></a>3.类文件是怎么加载进虚拟机的？</h4><p>这个之后详细介绍。</p>
<h3 id="QUESTION-3-请简单介绍一下类和对象的定义？"><a href="#QUESTION-3-请简单介绍一下类和对象的定义？" class="headerlink" title="QUESTION 3: 请简单介绍一下类和对象的定义？"></a>QUESTION 3: 请简单介绍一下类和对象的定义？</h3><p><strong>类</strong>是一段代码的名称，其中包含很多保存数据值的字段和操作这些值的方法。类是Java支持的五种引用类型之一，而且是最重要的一种。<br>类是一种数据类型，而类表示的值就是<strong>对象</strong>。对象一般通过实例化类创建，方法是使用new关键字并调用构造方法，例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point p = new Point(1.0,2.0);</div></pre></td></tr></table></figure>
<h3 id="QUESTION-4-请比较一下Java中引用类型和基本类型的不同？"><a href="#QUESTION-4-请比较一下Java中引用类型和基本类型的不同？" class="headerlink" title="QUESTION 4: 请比较一下Java中引用类型和基本类型的不同？"></a>QUESTION 4: 请比较一下Java中引用类型和基本类型的不同？</h3><p>在Java中，引用类型和对象与基本类型和基本值有着本质的区别。  </p>
<ol>
<li>八种基本类型由Java语言定义，程序员不能定义新的基本类型，而引用类型由用户定义，因此可以有无限多个。</li>
<li>基本类型表示单个值，而引用类型是聚合类型，可以保存零个或多个基本值或对象。</li>
<li>基本类型需要一到八个字节的内存空间。把基本值存储到变量中，或者传入方法时，实际上计算机会复制表示这个值的字节（也可以叫做<strong>传值</strong>）。而对象需要更多的内存，创建对象时会在<strong>堆(heap)</strong>动态分配内存，存储这个对象。如果不再需要使用这个对象了，存储它的内存会被自动<strong>垃圾回收</strong>。当把对象赋值给变量或是传入方法时，不会复制表示这个对象的内存，而是把这个内存的引用存储在变量中或传入方法(也可以叫<strong>传址</strong>)。</li>
</ol>
<h3 id="QUESTION-5-请简单介绍一下Java中字段的修饰符有哪些？"><a href="#QUESTION-5-请简单介绍一下Java中字段的修饰符有哪些？" class="headerlink" title="QUESTION 5: 请简单介绍一下Java中字段的修饰符有哪些？"></a>QUESTION 5: 请简单介绍一下Java中字段的修饰符有哪些？</h3><ol>
<li><strong>public,protected,private。</strong>这些访问控制修饰符指明字段能否在定义它的类之外使用，以及能在何处使用。</li>
<li><strong>static。</strong>这个修饰符指明字段关联在定义在它的类自身上，而不是类的实例身上。（注意，公开的静态字段要尽量声明为final，因为多个线程都能够修改字段的值，会导致极难调试的行为）。</li>
<li><strong>final。</strong>这个修饰符指明字段一旦初始化，其值就不能改变。如果字段同时使用static和final修饰，那么这个字段就是编译时常量，Javac会将其内联化。</li>
<li><strong>transient。</strong>这个修饰符指明字段不是对象持久状态的一部分，无需跟对象的其他内容一起序列化。</li>
<li><strong>volatile。</strong>这个修饰符指明字段可以被两个或多个线程同时使用，其深层含义是指字段的值必须始终从主存储器中读取和释放，不能够被线程缓存(在寄存器或者CPU缓存中)。</li>
</ol>
<h3 id="QUESTION-6-Java中的方法重载和方法覆盖区别是什么？"><a href="#QUESTION-6-Java中的方法重载和方法覆盖区别是什么？" class="headerlink" title="QUESTION 6: Java中的方法重载和方法覆盖区别是什么？"></a>QUESTION 6: Java中的方法重载和方法覆盖区别是什么？</h3><ol>
<li><strong>方法重载</strong>指的是在同一个中定义多个名称相同但是参数列表不同的方法。</li>
<li><strong>方法覆盖</strong>指的是如果类中的某个实例方法和超类中的某个方法有相同的名称、返回值类型和参数，那么这个方法会<strong>覆盖(override)</strong>超类中对应的方法。在这个类的对象上调用这个方法时，调用的是新定义的方法，而不是超类中定义的旧方法。下面是一个小例子，注意，下面的例子同时也展示了方法覆盖和字段遮盖之间的区别。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class A &#123;</div><div class="line">	int i = 1;</div><div class="line">	int f() &#123; return i; &#125;</div><div class="line">	static char g() &#123; return &apos;A&apos;; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B extends A &#123;</div><div class="line">	int i = 2;</div><div class="line">	int f() &#123; return -i; &#125;</div><div class="line">	static char g() &#123; return &apos;B&apos;; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static OverrideTest &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		B b = new B();</div><div class="line">		System.out.println(b.i); //引用B.i, 打印2</div><div class="line">		System.out.println(b.f()); //引用B.f(), 打印-2</div><div class="line">		System.out.println(b.g()); //引用B.g(), 打印B</div><div class="line">		System.out.println(B.g()); //更好的写法</div><div class="line">		A a = (A)b; // 把b矫正成类A的实例</div><div class="line">		System.out.println(b.i); //引用A.i, 打印1</div><div class="line">		System.out.println(b.f()); //引用B.f(), 打印-2</div><div class="line">		System.out.println(b.g()); //引用A.g(), 打印A</div><div class="line">		System.out.println(B.g()); //更好的写法</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现方法覆盖这个看起来很神奇的功能背后的机制在于，Javac生成的字节码会在运行时使用“虚拟方法查找(virtual method lookup)”。解释器运行代码时，会查找变量引用对象的真正运行时类型，然后找到适用于这个类型的对应方法。</p>
<h3 id="QUESTION-7-封装的含义是什么？其意义在于？"><a href="#QUESTION-7-封装的含义是什么？其意义在于？" class="headerlink" title="QUESTION 7: 封装的含义是什么？其意义在于？"></a>QUESTION 7: 封装的含义是什么？其意义在于？</h3><p>简单来说，<strong>封装(encapsulation)</strong>就是把数据隐藏在类中，只能通过方法获取。<br>其意义在于以下两点：  </p>
<ol>
<li>最重要的原因在于，<strong>隐藏类的内部实现细节</strong>，避免让程序员依赖这些细节，从而可以放心的对内部实现细节进行修改而无需担心破坏使用这个类的现有代码。</li>
<li>另一个原因在于<strong>保护类</strong>，防止因直接操作字段导致类的状态出现前后不一致。</li>
</ol>
<h3 id="QUESTION-8-请介绍一下Java中的嵌套类型？"><a href="#QUESTION-8-请介绍一下Java中的嵌套类型？" class="headerlink" title="QUESTION 8: 请介绍一下Java中的嵌套类型？"></a>QUESTION 8: 请介绍一下Java中的嵌套类型？</h3><h4 id="1-常见嵌套类型"><a href="#1-常见嵌套类型" class="headerlink" title="1.常见嵌套类型"></a>1.常见嵌套类型</h4><p><strong>嵌套类(又常被称为内部类)</strong>通常是指在其他类型中定义的类，其主要有两个目的：</p>
<ol>
<li><strong>如果某个类需要特别深入地访问另一个类的内部实现，就可以嵌套定义这个类。</strong>作为成员类型的嵌套类型，其访问方式与访问成员变量和方法的方式一样，而且能打破封装的规则。</li>
<li><strong>某个类型可能只在特定的情况下需要使用，而且只在非常小的代码区域使用。</strong>这个类型应该密封在一个小范围内(其他模块无法接触到的地方)，因为它实际上是实现细节的一部分。</li>
</ol>
<p>类能够通过四种不同的方式嵌套在其他类中。</p>
<ol>
<li><strong>静态成员类型。</strong>它和普通的顶层类型很像，只是为了方便，把它嵌套在另一个类型的命名空间中。静态成员类型具有如下几点基本特性：<ul>
<li>类似于类的其他静态成员: 静态字段和方法。</li>
<li>静态成员类型和所在类的任何实例都不关联(即没有this对象)，这个很好理解，因为静态成员类型也是绑定在类上而不是实例上的。</li>
<li>静态成员类型只能访问所在类的静态成员，包括私有成员，反过来也成立。</li>
<li>不管是否使用static关键字，嵌套的接口、枚举和注解都隐式声明为静态类型。</li>
</ul>
</li>
<li><strong>非静态成员类。</strong><ul>
<li>如果把静态成员类型比作类字段或者类方法，那么非静态成员类可以比作<strong>实例字段或者实例方法</strong>。</li>
<li>一个非静态成员类的实例始终关联一个外层类型的实例。</li>
<li>非静态成员类的代码能访问外层类型的所有字段和方法(静态+非静态)。</li>
<li>非静态成员类不能包含任何静态字段、方法或类型，这是因为静态成员是顶层结构，不和任何特定的对象相关联，而非静态成员类和外层类的实例相关联。在成员类中定义顶层的静态成员会让人困惑，因此禁止这么做。</li>
</ul>
</li>
<li><strong>局部类。</strong>必须在一个Java代码块中声明，不是类的成员。和局部变量一样，局部类只在定义它的块中有效。<ul>
<li>局部类能使用同一个作用域的局部变量，方法参数和异常参数，但是这些变量或参数必须声明为final。这是因为，局部类用到的每一个局部变量都有一个私有内部副本(由Javac自动生成)。并且，局部类实例的生命周期可能比定义它的方法执行时间长的多，所以只有把局部变量声明为final才能保证局部变量和私有副本始终保持一致。例子如下：</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class A &#123; protected char a = &apos;a&apos;; &#125;</div><div class="line">class B &#123; protected char b = &apos;b&apos;; &#125;</div><div class="line">public class C extends A &#123;</div><div class="line">	private char c = &apos;c&apos;; //私有字段，对局部类可见</div><div class="line">	public static char d = &apos;d&apos;;</div><div class="line">	public void createLocalObject(final char e) &#123;</div><div class="line">		final char f = &apos;f&apos;;</div><div class="line">		int i = 0;</div><div class="line">		class Local extends B &#123;</div><div class="line">			char g = &apos;g&apos;;</div><div class="line">			public void printVars() &#123;</div><div class="line">				System.out.println(g); // this.g</div><div class="line">				System.out.println(f); // f是声明为final的局部变量</div><div class="line">				System.out.println(e); // e是声明为final的局部变量</div><div class="line">				System.out.println(d); // C.this.d</div><div class="line">				System.out.println(c); // C.this.c</div><div class="line">				System.out.println(b); // b是这个类继承的字段</div><div class="line">				System.out.println(a); // a是外层类继承的字段</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		Local l = new Local();</div><div class="line">		l.printVars();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong>匿名类。</strong>其实就是没有名称的局部类。<ul>
<li>因为没有名称，所以匿名类无法实现构造方法。</li>
<li>在Java 8中，大多数情况下匿名类已经被lambda表达式替换。</li>
</ul>
</li>
</ol>
<h4 id="2-嵌套类型的运作方式"><a href="#2-嵌套类型的运作方式" class="headerlink" title="2.嵌套类型的运作方式"></a>2.嵌套类型的运作方式</h4><p>首先需要确定的是，<strong>引入嵌套类型后，Java虚拟机和Java类文件的格式都没有变化。对Java解释器而言，并没有所谓的嵌套类型，所有类都是普通的顶层类。</strong><br>为了实现嵌套类型，javac把每个嵌套类型编译为单独的类文件，得到的其实是顶层类。编译得到的类文件使用特殊的命名约定，如下所示：</p>
<ul>
<li>(静态或非静态)成员类型。根据EnclosingType$Member.class格式命名成员类型的类文件。</li>
<li>匿名类。因为匿名类没有名称，所以由具体的实现细节决定。Oracle/OpenJDK中的javac使用数字表示匿名类的名称(EnclosingType$1.class)。</li>
<li>局部类。综合使用前两种方式命名(EnclosingType$1Member.class)。</li>
</ul>
<p>因为嵌套类型编译成普通的顶层类，所以不能直接访问外层类型中具有特定权限的成员。javac通过在非静态成员类或局部类当中保存外层实例引用的方式，提供了嵌套类所需的合成访问能力。</p>
<h3 id="QUESTION-9-在Java中，应该使用接口还是抽象类？"><a href="#QUESTION-9-在Java中，应该使用接口还是抽象类？" class="headerlink" title="QUESTION 9: 在Java中，应该使用接口还是抽象类？"></a>QUESTION 9: 在Java中，应该使用接口还是抽象类？</h3><p>Java 8的出现从根本上改变了Java的面向对象编程模型。<br>在Java 8之前，接口纯粹是API规范，不包含实现。如果接口有大量实现，往往会导致代码重复。而Java 8中引入了默认方法，显著改变了这一情况。<br>一般来说，需要制定API规范时，推荐选择接口。接口中强制方法不是默认方法，因为它们是API的一部分，实现方要提供有效的实现。只有当方法是真正可选的，或者只有一种可能的实现时，才应该使用默认方法。</p>
<h3 id="QUESTION-10-请介绍并写一下单例模式"><a href="#QUESTION-10-请介绍并写一下单例模式" class="headerlink" title="QUESTION 10: 请介绍并写一下单例模式"></a>QUESTION 10: 请介绍并写一下单例模式</h3><p>单例模式(Singleton Pattern)是用来解决只需要为类创建一个实例这种设计问题。它是最简单的模式之一，一般用于管理配置，现代代码中也经常使用自动为程序员提供单例的框架(一般是<strong>依赖注入</strong>)。<br>单例虽然是很实用，但是由于存在有难测试，需考虑多线程等一些问题，要避免过度使用。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class Singleton &#123;</div><div class="line">	private final static Singleton instance = new Singleton();</div><div class="line">	private static boolean initialized = false;</div><div class="line">	</div><div class="line">	private Singleton() &#123;</div><div class="line">		super();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private void init() &#123;</div><div class="line">		// 做初始化操作</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static synchronized Singleton getInstance() &#123;</div><div class="line">		if (initialized) return instance;</div><div class="line">		instance.init();</div><div class="line">		initialized = true;</div><div class="line">		return instance;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="roronoa" />
          <p class="site-author-name" itemprop="name">roronoa</p>
           
              <p class="site-description motion-element" itemprop="description">you cannot win with a losing hand</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">roronoa</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
